#include <iostream>
#include "windows.h"
#include <fstream>
#include <stack>
#include <queue>
#include <vector>
#include <map>

using namespace std;

bool str_copy(char* des, char* source, int len);

// Defining DataStructures.
class semantic
{
	char type[10];							// It stores type of identifier.
	char id[22];							// It stores name of identifier.
	bool func;								// It is Ture if function is declared.
public:
	semantic()
	{
		type[0] = '\0';
		id[0] = '\0';
		func = false;
	}
	void set_type(char* a)
	{
		str_copy(type, a, strlen(a));
	}
	void set_id(char* a)
	{
		str_copy(id, a, strlen(a));
	}
	void set_func(bool a) { func = a; }

	char* get_type() { return type; }
	char* get_id() { return id; };
	bool is_func() { return func; }
};

// Defining Global variables e.g keywords, bool etc.

// Maximum length a token can have.
#define max_Token_length 22

// KeyWords are pointed using this.
char** keyWords;

// bool constants are pointed using this.
char** bool_constants;

// Operators are pointed using this.
char** operators;

// It will point to memory map of a file.
char* filePointer;

// It will point to current location of a file. 
int fileLocation;

// Handle of files for tookens and identifier...
HANDLE tokens, identifiers;

// Char input for a Parser...
char parse_input[10];

// It maintains stack for productions.
stack<char*> prod;

// It stores parse table.
char* parse_table[35][35];

// It stores rows name of a parse table, which are non-Terminals.
char* parse_row[35];

// It stores cols name of a parse  table, which are Terminals.
char* parse_col[35];

// Total number of Terminals.
int Terminals = 35;

// Total number of  non-Terminals.
int non_Terminals = 35;

// It is true if syntax is not correct.
bool stop_program = false;

// It stores semantic information temporarily.
semantic* semantic_temp;

// It stores variable declaritions of a program.
vector<semantic*> symbol_table;

// It is true if Variable Declaration is performed.
bool variable_decl = false;

// It is true if Function Declaration is performed.
bool func_decl = false;

// It will set on id arrival.
bool operator_check = false;

// It stores previous identifier for type checking.
char prev_id_name[25];

// It is used in get_const_type.
char get_type[10];

// It stores identifiers and constants to help in intermediate Code generation.
stack <char*> id_stack;

// It stores queues to generate labels in intermediate code generation.
// It helps in ifStmt labels.
stack<queue<int>*> labels_stack;

// It stores labels count generated upto now.
int labelCount = 0;


// It stores register number has been used.
int registerCount = 0;

// It is used for filing of intermedite code generation.
HANDLE code_file;

// Map Actions to a char**.
typedef void (*Action_Num)();
map<char*, Action_Num> ActionMap;

// ************************** Defining functions ***************************

// *******************  Defining Actions for Intermediate Code Generation ***********************

// It will perform an action A0 of grammer. 
// New queue, increment labelCount, Write in a file.
// LabelCount value is used first and than incremented for use afterwards.
void Action_0()
{
	// It stores code to be written in a file.
	char code[60];
	// Initializing code array as an empty array.
	code[0] = '\0';

	// It stores number in a char*.
	char num[10];

	// Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	queue<int>* a = new queue<int>;

	// Push this queue in a stack.
	labels_stack.push(a);

	// Saving code in a char array.
	strcat_s(code, (char*)"if R");

	// Convert Register Number in char*
	_itoa_s(registerCount - 1, num, 10);

	// Concat code upto now.
	strcat_s(code, num);

	// Now code of First label.
	strcat_s(code, (char*)" goto L");

	// convert labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);

	// Enqueue labelCount in queue. 
	a->push(labelCount);

	// Increment labelCount for Second label.
	labelCount++;

	strcat_s(code, (char*)"\ngoto L");

	// convert labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);

	// Enqueue labelCount in a queue.
	a->push(labelCount);
	labelCount++;

	// Now start point of first label.
	strcat_s(code, (char*)"\nL");
	_itoa_s(a->front(), num, 10);

	// Now dequeue Label, which has been used.
	a->pop();
	strcat_s(code, num);
	strcat_s(code, (char*)":\n");

	// Intermediate Code has to generated by this function is present in code array.
	// Now writting this code in a file.
	WriteFile(code_file, code, strlen(code), NULL, NULL);
}

// It checks queue on top of labels stack should be empty. pop that queue.
// It will place a label where if statement ends. 
void Action_1()
{
	// It stores to be generated by this function.
	char code[20];
	// Initialize code array as an empty array.
	code[0] = '\0';
	// It stores labelCount in char*.
	char num[10];
	// Initialize num array as an empty array.
	num[0] = '\0';

	strcat_s(code, (char*)"L");
	// Stores labelCount in char*.
	_itoa_s(labels_stack.top()->front(), num, 10);
	strcat_s(code, num);
	// Dequeue labelCount which has been used.
	labels_stack.top()->pop();
	strcat_s(code, (char*)":\n");

	if (labels_stack.top()->empty())
	{
		cout << "Action_1: Queue is empty." << endl;
		labels_stack.pop();
	}
	else
	{
		cout << "Action_1: Queue is not empty. Still poping it..." << endl;
		system("pause");
		labels_stack.pop();
	}
	WriteFile(code_file, code, strlen(code), NULL, NULL);
}

// It will be called when else statment is declared.
// It will enqueue 
void Action_2()
{
	// It stores code to be written in a file.
	char code[20];
	// Initializing code array as an empty array.
	code[0] = '\0';

	// It stores number in a char*.
	char num[10];
	// Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	// Concat code.
	strcat_s(code, (char*)"goto L");
	// Save labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, (char*)num);
	// Insert new labelCount in a queue at top of a stack. Induced because of Else statement.
	labels_stack.top()->push(labelCount);

	// Now label for else statement.
	strcat_s(code, (char*)"\nL");
	// Store labelNumber of else statement in char*.
	_itoa_s(labels_stack.top()->front(), num, 10);
	// Dequeue labelCount that has been used.
	labels_stack.top()->pop();

	strcat_s(code, num);
	strcat_s(code, (char*)":\n");

	WriteFile(code_file, code, strlen(code), NULL, NULL);
}

// It will perform Wh_St action, named as A_3
void Action_3()
{
	// It stores code to be written in a file.
	char code[20];

	// Initializing code array as an empty array.
	code[0] = '\0';

	// It stores number in a char*.
	char num[10];

	// Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	// New queue for every while statement.
	queue<int>* a = new queue<int>;

	// Push this queue in a stack.
	labels_stack.push(a);

	strcat_s(code, (char*)"L");
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);
	labelCount++;
	strcat_s(code, (char*)":\n");

	WriteFile(code_file, code, strlen(code), NULL, NULL);
}

void Action_4()
{
	// It stores code to be written in a file.
	char code[60];

	// Initializing code array as an empty array.
	code[0] = '\0';

	// It stores number in a char*.
	char num[10];

	// Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';
	queue<int>* a = labels_stack.top();

	// Saving code in a char array.
	strcat_s(code, (char*)"if R");

	// Convert Register Number in char*
	_itoa_s(registerCount - 1, num, 10);

	// Concat code upto now.
	strcat_s(code, num);

	// Now code of First label.
	strcat_s(code, (char*)" goto L");

	// convert labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);

	// Enqueue labelCount in queue. 
	a->push(labelCount);

	// Increment labelCount for Second label.
	labelCount++;
	strcat_s(code, (char*)"\ngoto L");

	// convert labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);

	// Enqueue labelCount in a queue.
	a->push(labelCount);
	labelCount++;

	// Now start point of first label.
	strcat_s(code, (char*)"\nL");
	_itoa_s(a->front(), num, 10);

	// Now dequeue Label, which has been used.
	a->pop();
	strcat_s(code, num);
	strcat_s(code, (char*)":\n");

	// Intermediate Code has to generated by this function is present in code array.
	// Now writting this code in a file.
	WriteFile(code_file, code, strlen(code), NULL, NULL);
}

void Action_5()
{
	// It stores code to be generated by this function.
	char code[20];

	// Initialize code array as an empty array.
	code[0] = '\0';

	// It stores labelCount in char*.
	char num[10];

	// Initialize num array as an empty array.
	num[0] = '\0';

	strcat_s(code, (char*)"goto L");

	// Stores labelCount where jump is to be placed in char*.
	_itoa_s(labels_stack.top()->front() - 2, num, 10);
	strcat_s(code, num);

	strcat_s(code, (char*)"\nL");

	// Stores labelCount in char*.
	_itoa_s(labels_stack.top()->front(), num, 10);
	strcat_s(code, num);

	// Dequeue labelCount which has been used.
	labels_stack.top()->pop();

	strcat_s(code, (char*)":\n");
	labels_stack.pop();

	WriteFile(code_file, code, strlen(code), NULL, NULL);
}

void Action_6()
{
	WriteFile(code_file, "ret\n", 4, NULL, NULL);
}

void Action_7()
{
	cout << "Should I implement it?" << endl;
}

// It will be called on actuals arrival.
// It will pop recent identifier pushed on a stack.
void Action_8()
{
	id_stack.pop();
}

// It implements action of an assignment operator.
void Action_9()
{
	// It stores code to be written in a file.
	char code[60];

	// Initializing code array as an empty array.
	code[0] = '\0';

	// It stores number in a char*.
	char num[10];

	// Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	// It stores name of identifier which should be on right side of an equation.
	char* assign_id;

	assign_id = id_stack.top();
	id_stack.pop();

	// Assignment will always be at top of id_stack.
	strcat_s(code, id_stack.top());

	// Now pop element at top of stack.
	id_stack.pop();

	// Place an equal operator in assignment operation.
	strcat_s(code, " = ");

	// Place right side of an assignment operation.
	strcat_s(code, assign_id);
	strcat_s(code, (char*)"\n");

	WriteFile(code_file, code, strlen(code), NULL, NULL);
}

// It will push identifier on a stack of Identifiers.
void Action_10(char* a)
{
	char* push = new char[strlen(a) + 1];
	strcpy_s(push, strlen(a) + 1, a);
	id_stack.push(push);
	cout << "id_stack top is: " << id_stack.top() << endl;
}

// It will implement actions of Expression operators.
// Pop last 02 operands, place operator between them and assign to register.
void Action_11(int a)
{
	// It stores code to be written in a file.
	char code[60];

	// Initializing code array as an empty array.
	code[0] = '\0';

	// It stores number in a char*.
	char num[10];

	// Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	// It stores register to be pushed on stack which stores result of this operation.
	char* reg_push = new char[10];
	reg_push[0] = '\0';

	// It stores right operand of an operator.
	char* right_operand;

	// Assignment of result to a new register.
	strcat_s(code, (char*)"R");
	_itoa_s(registerCount++, num, 10);
	strcat_s(code, num);

	// strcat_s(reg_push, (char*)"R");
	strcat_s(reg_push, 10, code);
	strcat_s(code, (char*)" = ");
	right_operand = id_stack.top();
	id_stack.pop();

	// Place Left operand of an operator in code array.
	strcat_s(code, id_stack.top());
	id_stack.pop();

	// Now decide which operation has to be implemented.
	switch (a)
	{
	case 0:
		strcat_s(code, (char*)" || ");
		break;
	case 1:
		strcat_s(code, (char*)" && ");
		break;
	case 2:
		strcat_s(code, (char*)" == ");
		break;
	case 3:
		strcat_s(code, (char*)" != ");
		break;
	case 4:
		strcat_s(code, (char*)" < ");
		break;
	case 5:
		strcat_s(code, (char*)" > ");
		break;
	case 6:
		strcat_s(code, (char*)" <= ");
		break;
	case 7:
		strcat_s(code, (char*)" >= ");
		break;
	case 8:
		strcat_s(code, (char*)" + ");
		break;
	case 9:
		strcat_s(code, (char*)" - ");
		break;
	case 10:
		strcat_s(code, (char*)" * ");
		break;
	case 11:
		strcat_s(code, (char*)" / ");
		break;
	case 12:
		strcat_s(code, (char*)" % ");
		break;
	}

	strcat_s(code, right_operand);
	strcat_s(code, (char*)"\n");

	// Now push register on stack which stores results of this operation.
	id_stack.push(reg_push);

	if (0 == WriteFile(code_file, code, strlen(code), NULL, NULL))
	{
		cout << "Error in writing file from Action_11. Error code: " << GetLastError() << endl;
		exit(-1);
	}

}

// It creates mapping of All actions.
// Except Action_8 and Action_11.
void init_Action()
{
	ActionMap[(char*)"A_0"] = Action_0;
	ActionMap[(char*)"A_1"] = Action_1;
	ActionMap[(char*)"A_2"] = Action_2;
	ActionMap[(char*)"A_3"] = Action_3;
	ActionMap[(char*)"A_4"] = Action_4;
	ActionMap[(char*)"A_5"] = Action_5;
	ActionMap[(char*)"A_6"] = Action_6;
	ActionMap[(char*)"A_7"] = Action_7;
	ActionMap[(char*)"A_9"] = Action_9;
	// ActionMap[(char*)"A_10"] = Action_10;
	ActionMap[(char*)"A_8"] = Action_8;
}

// It returns true if both arrays are equal.
bool isEqual(char* a, char* b)
{
	int i = 0;
	while (a[i] == b[i] && a[i] != '\0' && b[i] != '\0')
	{
		i++;
	}
	if (a[i] == b[i])
	{
		return true;
	}
	else return false;
}

bool isConstant(char* a)
{
	if (isEqual(a, (char*)"intConst"))
		return true;
	else if (isEqual(a, (char*)"doubConst"))
		return true;
	else if (isEqual(a, (char*)"strConst"))
		return true;
	else if (isEqual(a, (char*)"boolConst"))
		return true;

	return false;
}

// It returns if variable is already declared.
// Use = true, if whole stack is need to be searched for declaration.
// It checks wether the variable is already declared in this scope or not.
// Use check search the whole list for search of variable declaration.
bool isVariDecl(char* a, bool use)
{
	for (int i = 0; i < symbol_table.size(); i++)
	{
		if (isEqual(symbol_table.at(i)->get_type(), (char*)"new") && !use) // Checks New scope is started.
		{
			break;
		}
		if (isEqual(symbol_table.at(i)->get_id(), a))
			return true;
	}
	return false;
}

bool isType(char* a)
{
	if (isEqual(a, (char*)"bool") || \
		isEqual(a, (char*)"string") || \
		isEqual(a, (char*)"int") || \
		isEqual(a, (char*)"double") || \
		isEqual(a, (char*)"float"))
	{
		return true;
	}
	else false;
}

// It inserts a delemiter in symbol table for new scope.
bool initialize_scope()
{
	semantic_temp = new semantic;
	semantic_temp->set_type((char*)"new");
	semantic_temp->set_id((char*)"new");
	symbol_table.insert(symbol_table.begin(), semantic_temp);
	return true;
}

// It removes most recent uploaded scope.
bool pop_recent_scope()
{
	while (!isEqual((char*)"new", symbol_table.front()->get_type()))
	{
		symbol_table.erase(symbol_table.begin());
	}
	symbol_table.erase(symbol_table.begin());

	return true;
}

bool check_type(char* a, char* b)
{
	char type_a[10];
	char type_b[10];
	for (int i = 0; i < symbol_table.size(); i++)
	{
		if (isEqual(symbol_table.at(i)->get_id(), a))
			str_copy(type_a, symbol_table.at(i)->get_type(), strlen(a));
		else if (isEqual(symbol_table.at(i)->get_id(), b))
			str_copy(type_b, symbol_table.at(i)->get_type(), strlen(b));
	}
	if (isEqual(type_a, type_b))
		return true;
	else return false;
}

bool comp_type(char* var, char* type)
{
	char type_a[10];
	for (int i = 0; i < symbol_table.size(); i++)
	{
		if (isEqual(symbol_table.at(i)->get_id(), var))
		{
			strcpy_s(type_a, symbol_table.at(i)->get_type());
			break;
		}
	}

	if (isEqual(type_a, type))
		return true;
	else return false;
}

char* get_const_type(char* a)
{
	if (isEqual(a, (char*)"intConst"))
		str_copy(get_type, (char*)"int", 3);
	else if (isEqual(a, (char*)"doubConst"))
		str_copy(get_type, (char*)"float", 5);
	else if (isEqual(a, (char*)"strConst"))
		str_copy(get_type, (char*)"string", 6);
	else if (isEqual(a, (char*)"boolConst"))
		str_copy(get_type, (char*)"bool", 4);

	return get_type;
}

char* get_type_name(char* a)
{
	char type_a[10];
	for (int i = 0; i < symbol_table.size(); i++)
	{
		if (isEqual(symbol_table.at(i)->get_id(), a))
		{
			str_copy(type_a, symbol_table.at(i)->get_type(), strlen(a));
			break;
		}
	}
	return type_a;
}

void print_symbol_table()
{
	cout << "\n\n***Printing Symbol Table***" << endl;
	for (int i = 0; i < symbol_table.size(); i++)
	{
		cout << "Id: " << symbol_table.at(i)->get_id() << ". Type: " << symbol_table.at(i)->get_type() << endl;
	}
	system("pause");
	cout << "***End of Symbol Table.***" << endl << endl;
}


// ****************************  Syntax Analyzer Functions *******************************

void init_parse()
{
	// Initializing Stack.
	prod.push((char*)"$");
	prod.push((char*)"Prog");

	// Initializing Terminals...
	parse_row[0] = (char*)"Prog";
	parse_row[1] = (char*)"Prog'";
	parse_row[2] = (char*)"Decl";
	parse_row[3] = (char*)"Decl'";
	parse_row[4] = (char*)"VariDecl";
	parse_row[5] = (char*)"Variable";
	parse_row[6] = (char*)"Type";
	parse_row[7] = (char*)"Formals";
	parse_row[8] = (char*)"Formals'";
	parse_row[9] = (char*)"StmtBlk";
	parse_row[10] = (char*)"StmtBa'";
	parse_row[11] = (char*)"StmtBb'";
	parse_row[12] = (char*)"Stmt";
	parse_row[13] = (char*)"IfStmt";
	parse_row[14] = (char*)"IfStmt'";
	parse_row[15] = (char*)"Wh_St";
	parse_row[16] = (char*)"Ret_St";
	parse_row[17] = (char*)"Ret_St'";
	parse_row[18] = (char*)"Actuals";
	parse_row[19] = (char*)"Actuals'";
	parse_row[20] = (char*)"Const";
	parse_row[21] = (char*)"Expr";
	parse_row[22] = (char*)"A'";
	parse_row[23] = (char*)"B";
	parse_row[24] = (char*)"B'";
	parse_row[25] = (char*)"C";
	parse_row[26] = (char*)"C'";
	parse_row[27] = (char*)"D";
	parse_row[28] = (char*)"D'";
	parse_row[29] = (char*)"E";
	parse_row[30] = (char*)"E'";
	parse_row[31] = (char*)"F";
	parse_row[32] = (char*)"F'";
	parse_row[33] = (char*)"G";
	parse_row[34] = (char*)"G'";

	// Initializing Non-Terminals.
	parse_col[0] = (char*)"int";
	parse_col[1] = (char*)"double";
	parse_col[2] = (char*)"bool";
	parse_col[3] = (char*)"string";
	parse_col[4] = (char*)";";
	parse_col[5] = (char*)"(";
	parse_col[6] = (char*)",";
	parse_col[7] = (char*)"{";
	parse_col[8] = (char*)"if";
	parse_col[9] = (char*)"while";
	parse_col[10] = (char*)"return";
	parse_col[11] = (char*)"id";
	parse_col[12] = (char*)"intConst";
	parse_col[13] = (char*)"doubConst";
	parse_col[14] = (char*)"boolConst";
	parse_col[15] = (char*)"strConst";
	parse_col[16] = (char*)"null";
	parse_col[17] = (char*)"else";
	parse_col[18] = (char*)"||";
	parse_col[19] = (char*)"&&";
	parse_col[20] = (char*)"==";
	parse_col[21] = (char*)"!=";
	parse_col[22] = (char*)"<";
	parse_col[23] = (char*)"<=";
	parse_col[24] = (char*)">";
	parse_col[25] = (char*)">=";
	parse_col[26] = (char*)"+";
	parse_col[27] = (char*)"-";
	parse_col[28] = (char*)"=";
	parse_col[29] = (char*)"*";
	parse_col[30] = (char*)"/";
	parse_col[31] = (char*)"%";
	parse_col[32] = (char*)"$";
	parse_col[33] = (char*)")";
	parse_col[34] = (char*)"}";

	// Now Initializing Parse Table Enteries.
	for (int i = 0; i < non_Terminals; i++)
	{
		for (int j = 0; j < Terminals; j++)
		{
			parse_table[i][j] = NULL;
		}
	}
	// Prog
	parse_table[0][0] = (char*)"Decl Prog'";
	parse_table[0][1] = (char*)"Decl Prog'";
	parse_table[0][2] = (char*)"Decl Prog'";
	parse_table[0][3] = (char*)"Decl Prog'";

	// Prog'
	parse_table[1][0] = (char*)"Decl Prog'";
	parse_table[1][1] = (char*)"Decl Prog'";
	parse_table[1][2] = (char*)"Decl Prog'";
	parse_table[1][3] = (char*)"Decl Prog'";
	parse_table[1][32] = (char*)"epsilon";

	// Decl
	parse_table[2][0] = (char*)"Type id Decl'";
	parse_table[2][1] = (char*)"Type id Decl'";
	parse_table[2][2] = (char*)"Type id Decl'";
	parse_table[2][3] = (char*)"Type id Decl'";

	// Decl'
	parse_table[3][4] = (char*)";";
	parse_table[3][5] = (char*)"( Formals ) StmtBlk";

	// VariDecl
	parse_table[4][0] = (char*)"Variable ;";
	parse_table[4][1] = (char*)"Variable ;";
	parse_table[4][2] = (char*)"Variable ;";
	parse_table[4][3] = (char*)"Variable ;";

	// Variable
	parse_table[5][0] = (char*)"Type id";
	parse_table[5][1] = (char*)"Type id";
	parse_table[5][2] = (char*)"Type id";
	parse_table[5][3] = (char*)"Type id";

	// Type
	parse_table[6][0] = (char*)"int";
	parse_table[6][1] = (char*)"double";
	parse_table[6][2] = (char*)"bool";
	parse_table[6][3] = (char*)"string";

	// Formals
	parse_table[7][0] = (char*)"Variable Formals'";
	parse_table[7][1] = (char*)"Variable Formals'";
	parse_table[7][2] = (char*)"Variable Formals'";
	parse_table[7][3] = (char*)"Variable Formals'";
	parse_table[7][33] = (char*)"epsilon";

	// Formals'
	parse_table[8][6] = (char*)", Variable Formals'";
	parse_table[8][33] = (char*)"epsilon";

	// StmtBlk
	parse_table[9][7] = (char*)"{ StmtBa' }";

	// StmtBa'
	parse_table[10][0] = (char*)"VariDecl StmtBa'";
	parse_table[10][1] = (char*)"VariDecl StmtBa'";
	parse_table[10][2] = (char*)"VariDecl StmtBa'";
	parse_table[10][3] = (char*)"VariDecl StmtBa'";
	parse_table[10][4] = (char*)"StmtBb'";
	parse_table[10][5] = (char*)"StmtBb'";
	parse_table[10][7] = (char*)"StmtBb'";
	parse_table[10][8] = (char*)"StmtBb'";
	parse_table[10][9] = (char*)"StmtBb'";
	parse_table[10][10] = (char*)"StmtBb'";
	parse_table[10][11] = (char*)"StmtBb'";
	parse_table[10][12] = (char*)"StmtBb'";
	parse_table[10][13] = (char*)"StmtBb'";
	parse_table[10][14] = (char*)"StmtBb'";
	parse_table[10][15] = (char*)"StmtBb'";
	parse_table[10][16] = (char*)"StmtBb'";
	parse_table[10][34] = (char*)"epsilon";

	// StmtBb'
	parse_table[11][4] = (char*)"Stmt StmtBb'";
	parse_table[11][5] = (char*)"Stmt StmtBb'";
	parse_table[11][7] = (char*)"Stmt StmtBb'";
	parse_table[11][8] = (char*)"Stmt StmtBb'";
	parse_table[11][9] = (char*)"Stmt StmtBb'";
	parse_table[11][10] = (char*)"Stmt StmtBb'";
	parse_table[11][11] = (char*)"Stmt StmtBb'";
	parse_table[11][12] = (char*)"Stmt StmtBb'";
	parse_table[11][13] = (char*)"Stmt StmtBb'";
	parse_table[11][14] = (char*)"Stmt StmtBb'";
	parse_table[11][15] = (char*)"Stmt StmtBb'";
	parse_table[11][16] = (char*)"Stmt StmtBb'";
	parse_table[11][34] = (char*)"epsilon";

	// Stmt
	parse_table[12][4] = (char*)";";
	parse_table[12][5] = (char*)"Expr";
	parse_table[12][7] = (char*)"StmtBlk";
	parse_table[12][8] = (char*)"IfStmt";
	parse_table[12][9] = (char*)"Wh_St";
	parse_table[12][10] = (char*)"Ret_St";
	parse_table[12][11] = (char*)"Expr";
	parse_table[12][12] = (char*)"Expr";
	parse_table[12][13] = (char*)"Expr";
	parse_table[12][14] = (char*)"Expr";
	parse_table[12][15] = (char*)"Expr";
	parse_table[12][16] = (char*)"Expr";

	// IfStmt
	parse_table[13][8] = (char*)"if ( Expr ) A_0 Stmt IfStmt' A_1";

	// IfStmt'
	parse_table[14][17] = (char*)"A_2 else Stmt";
	parse_table[14][4] = (char*)"epsilon";
	parse_table[14][5] = (char*)"epsilon";
	parse_table[14][7] = (char*)"epsilon";
	parse_table[14][8] = (char*)"epsilon";
	parse_table[14][9] = (char*)"epsilon";
	parse_table[14][10] = (char*)"epsilon";
	parse_table[14][11] = (char*)"epsilon";
	parse_table[14][12] = (char*)"epsilon";
	parse_table[14][13] = (char*)"epsilon";
	parse_table[14][14] = (char*)"epsilon";
	parse_table[14][15] = (char*)"epsilon";
	parse_table[14][16] = (char*)"epsilon";
	parse_table[14][34] = (char*)"epsilon";

	// Wh_St
	parse_table[15][9] = (char*)"while A_3 ( Expr ) A_4 Stmt A_5";

	// Ret_St
	parse_table[16][10] = (char*)"return A_6 Ret_St' ;";

	// Ret_St'
	parse_table[17][5] = (char*)"Expr";
	parse_table[17][11] = (char*)"Expr";
	parse_table[17][12] = (char*)"Expr";
	parse_table[17][13] = (char*)"Expr";
	parse_table[17][14] = (char*)"Expr";
	parse_table[17][15] = (char*)"Expr";
	parse_table[17][16] = (char*)"Expr";

	// Actuals
	parse_table[18][5] = (char*)"Expr Actuals'";
	parse_table[18][11] = (char*)"Expr Actuals'";
	parse_table[18][12] = (char*)"Expr Actuals'";
	parse_table[18][13] = (char*)"Expr Actuals'";
	parse_table[18][14] = (char*)"Expr Actuals'";
	parse_table[18][15] = (char*)"Expr Actuals'";
	parse_table[18][16] = (char*)"Expr Actuals'";
	parse_table[18][33] = (char*)"epsilon";

	// Actuals'
	parse_table[19][6] = (char*)", Expr Actuals'";
	parse_table[19][33] = (char*)"epsilon";

	// Const
	parse_table[20][12] = (char*)"intConst A_10";
	parse_table[20][13] = (char*)"doubConst A_10";
	parse_table[20][14] = (char*)"boolConst A_10";
	parse_table[20][15] = (char*)"strConst A_10";
	parse_table[20][16] = (char*)"null";

	// Expr
	parse_table[21][5] = (char*)"B A'";
	parse_table[21][11] = (char*)"B A'";
	parse_table[21][12] = (char*)"B A'";
	parse_table[21][13] = (char*)"B A'";
	parse_table[21][14] = (char*)"B A'";
	parse_table[21][15] = (char*)"B A'";
	parse_table[21][16] = (char*)"B A'";

	// A'
	parse_table[22][18] = (char*)"|| B A_11 A'";
	parse_table[22][4] = (char*)"epsilon";
	parse_table[22][6] = (char*)"epsilon";
	parse_table[22][19] = (char*)"epsilon";
	parse_table[22][20] = (char*)"epsilon";
	parse_table[22][21] = (char*)"epsilon";
	parse_table[22][22] = (char*)"epsilon";
	parse_table[22][23] = (char*)"epsilon";
	parse_table[22][24] = (char*)"epsilon";
	parse_table[22][25] = (char*)"epsilon";
	parse_table[22][26] = (char*)"epsilon";
	parse_table[22][27] = (char*)"epsilon";
	parse_table[22][29] = (char*)"epsilon";
	parse_table[22][30] = (char*)"epsilon";
	parse_table[22][31] = (char*)"epsilon";
	parse_table[22][33] = (char*)"epsilon";

	// B
	parse_table[23][5] = (char*)"C B'";
	parse_table[23][11] = (char*)"C B'";
	parse_table[23][12] = (char*)"C B'";
	parse_table[23][13] = (char*)"C B'";
	parse_table[23][14] = (char*)"C B'";
	parse_table[23][15] = (char*)"C B'";
	parse_table[23][16] = (char*)"C B'";

	// B'
	parse_table[24][19] = (char*)"&& C A_12 B'";
	parse_table[24][4] = (char*)"epsilon";
	parse_table[24][6] = (char*)"epsilon";
	parse_table[24][18] = (char*)"epsilon";
	parse_table[24][20] = (char*)"epsilon";
	parse_table[24][21] = (char*)"epsilon";
	parse_table[24][22] = (char*)"epsilon";
	parse_table[24][23] = (char*)"epsilon";
	parse_table[24][24] = (char*)"epsilon";
	parse_table[24][25] = (char*)"epsilon";
	parse_table[24][26] = (char*)"epsilon";
	parse_table[24][27] = (char*)"epsilon";
	parse_table[24][29] = (char*)"epsilon";
	parse_table[24][30] = (char*)"epsilon";
	parse_table[24][31] = (char*)"epsilon";
	parse_table[24][33] = (char*)"epsilon";

	// C
	parse_table[25][5] = (char*)"D C'";
	parse_table[25][11] = (char*)"D C'";
	parse_table[25][12] = (char*)"D C'";
	parse_table[25][13] = (char*)"D C'";
	parse_table[25][14] = (char*)"D C'";
	parse_table[25][15] = (char*)"D C'";
	parse_table[25][16] = (char*)"D C'";

	// C'
	parse_table[26][18] = (char*)"epsilon";
	parse_table[26][4] = (char*)"epsilon";
	parse_table[26][6] = (char*)"epsilon";
	parse_table[26][19] = (char*)"epsilon";
	parse_table[26][20] = (char*)"== D A_13 C'";
	parse_table[26][21] = (char*)"!= D A_14 C'";
	parse_table[26][22] = (char*)"epsilon";
	parse_table[26][23] = (char*)"epsilon";
	parse_table[26][24] = (char*)"epsilon";
	parse_table[26][25] = (char*)"epsilon";
	parse_table[26][26] = (char*)"epsilon";
	parse_table[26][27] = (char*)"epsilon";
	parse_table[26][29] = (char*)"epsilon";
	parse_table[26][30] = (char*)"epsilon";
	parse_table[26][31] = (char*)"epsilon";
	parse_table[26][33] = (char*)"epsilon";

	// D
	parse_table[27][5] = (char*)"E D'";
	parse_table[27][11] = (char*)"E D'";
	parse_table[27][12] = (char*)"E D'";
	parse_table[27][13] = (char*)"E D'";
	parse_table[27][14] = (char*)"E D'";
	parse_table[27][15] = (char*)"E D'";
	parse_table[27][16] = (char*)"E D'";

	// D'
	parse_table[28][4] = (char*)"epsilon";
	parse_table[28][6] = (char*)"epsilon";
	parse_table[28][18] = (char*)"epsilon";
	parse_table[28][19] = (char*)"epsilon";
	parse_table[28][20] = (char*)"epsilon";
	parse_table[28][21] = (char*)"epsilon";
	parse_table[28][22] = (char*)"< E A_15 D'";
	parse_table[28][23] = (char*)"<= E A_16 D'";
	parse_table[28][24] = (char*)"> E A_17 D'";
	parse_table[28][25] = (char*)">= E A_18 D'";
	parse_table[28][26] = (char*)"epsilon";
	parse_table[28][27] = (char*)"epsilon";
	parse_table[28][29] = (char*)"epsilon";
	parse_table[28][30] = (char*)"epsilon";
	parse_table[28][31] = (char*)"epsilon";
	parse_table[28][33] = (char*)"epsilon";

	// E
	parse_table[29][5] = (char*)"F E'";
	parse_table[29][11] = (char*)"F E'";
	parse_table[29][12] = (char*)"F E'";
	parse_table[29][13] = (char*)"F E'";
	parse_table[29][14] = (char*)"F E'";
	parse_table[29][15] = (char*)"F E'";
	parse_table[29][16] = (char*)"F E'";


	// E'
	parse_table[30][4] = (char*)"epsilon";
	parse_table[30][6] = (char*)"epsilon";
	parse_table[30][18] = (char*)"epsilon";
	parse_table[30][19] = (char*)"epsilon";
	parse_table[30][20] = (char*)"epsilon";
	parse_table[30][21] = (char*)"epsilon";
	parse_table[30][22] = (char*)"epsilon";
	parse_table[30][23] = (char*)"epsilon";
	parse_table[30][24] = (char*)"epsilon";
	parse_table[30][25] = (char*)"epsilon";
	parse_table[30][26] = (char*)"+ F A_19 E'";
	parse_table[30][27] = (char*)"- F A_20 E'";
	parse_table[30][29] = (char*)"epsilon";
	parse_table[30][30] = (char*)"epsilon";
	parse_table[30][31] = (char*)"epsilon";
	parse_table[30][33] = (char*)"epsilon";

	// F
	parse_table[31][5] = (char*)"G F'";
	parse_table[31][11] = (char*)"G F'";
	parse_table[31][12] = (char*)"G F'";
	parse_table[31][13] = (char*)"G F'";
	parse_table[31][14] = (char*)"G F'";
	parse_table[31][15] = (char*)"G F'";
	parse_table[31][16] = (char*)"G F'";

	// F'
	parse_table[32][4] = (char*)"epsilon";
	parse_table[32][6] = (char*)"epsilon";
	parse_table[32][18] = (char*)"epsilon";
	parse_table[32][19] = (char*)"epsilon";
	parse_table[32][20] = (char*)"epsilon";
	parse_table[32][21] = (char*)"epsilon";
	parse_table[32][22] = (char*)"epsilon";
	parse_table[32][23] = (char*)"epsilon";
	parse_table[32][24] = (char*)"epsilon";
	parse_table[32][25] = (char*)"epsilon";
	parse_table[32][26] = (char*)"epsilon";
	parse_table[32][27] = (char*)"epsilon";
	parse_table[32][29] = (char*)"* G A_21 F'";
	parse_table[32][30] = (char*)"/ G A_22 F'";
	parse_table[32][31] = (char*)"% G A_23 F'";
	parse_table[32][33] = (char*)"epsilon";

	// G
	parse_table[33][5] = (char*)"( Expr )";
	parse_table[33][11] = (char*)"id A_10 G'";
	parse_table[33][12] = (char*)"Const";
	parse_table[33][13] = (char*)"Const";
	parse_table[33][14] = (char*)"Const";
	parse_table[33][15] = (char*)"Const";
	parse_table[33][16] = (char*)"Const";

	// G'
	parse_table[34][4] = (char*)"epsilon";
	parse_table[34][5] = (char*)"A_8 ( Actuals )";
	parse_table[34][6] = (char*)"epsilon";
	parse_table[34][18] = (char*)"epsilon";
	parse_table[34][19] = (char*)"epsilon";
	parse_table[34][20] = (char*)"epsilon";
	parse_table[34][21] = (char*)"epsilon";
	parse_table[34][22] = (char*)"epsilon";
	parse_table[34][23] = (char*)"epsilon";
	parse_table[34][24] = (char*)"epsilon";
	parse_table[34][25] = (char*)"epsilon";
	parse_table[34][26] = (char*)"epsilon";
	parse_table[34][27] = (char*)"epsilon";
	parse_table[34][28] = (char*)"= Expr A_9";
	parse_table[34][29] = (char*)"epsilon";
	parse_table[34][30] = (char*)"epsilon";
	parse_table[34][31] = (char*)"epsilon";
	parse_table[34][33] = (char*)"epsilon";

	/*
	parse_table[0][0] = (char*)"T E'";
	parse_table[0][3] = (char*)"T E'";


	parse_table[1][1] = (char*)"+ T E'";
	parse_table[1][4] = (char*)"epsilon";
	parse_table[1][5] = (char*)"epsilon";


	parse_table[2][0] = (char*)"F T'";
	parse_table[2][3] = (char*)"F T'";


	parse_table[3][1] = (char*)"epsilon";
	parse_table[3][2] = (char*)"* F T'";
	parse_table[3][4] = (char*)"epsilon";
	parse_table[3][5] = (char*)"epsilon";

	parse_table[4][0] = (char*)"id";
	parse_table[4][3] = (char*)"( E )";
*/
}

bool isTerminal(char* a)
{
	for (int i = 0; i < Terminals; i++)
	{
		if (isEqual(a, parse_col[i]))
		{
			return true;
		}
	}
	return false;
}

int Terminal_index(char* a)
{
	for (int i = 0; i < Terminals; i++)
	{
		if (isEqual(a, parse_col[i]))
		{
			return i;
		}
	}
	return -1;
}

// It returns index of non_Terminal to be matched.
int non_Terminal_index(char* a)
{
	for (int i = 0; i < non_Terminals; i++)
	{
		if (isEqual(a, parse_row[i]))
		{
			return i;
		}
	}
	return -1;
}

// It will copy "Bytes" src from start_index into des.
// It will not copy beyond the end of src string.
bool str_copy(char* des, char* src, int start_index, int bytes)
{
	int i = start_index;
	int count = 0;
	for (; src[i] != '\0' && count < bytes; i++)
	{
		des[count] = src[i];
		count++;
	}
	des[i - start_index] = '\0';
	return true;
}

int isConst(char* a)
{
	// It storeas constant types.
	char** constTypes;

	// It stores Total constant exists.
	int T_const = 4;

	// It is true if input part is matched with Constant Type. 
	bool match = false;

	constTypes = new char* [T_const];

	constTypes[0] = (char*)"intConst,";
	constTypes[1] = (char*)"doubConst,";
	constTypes[2] = (char*)"strConst,";

	// true, false, and null are in bool constant.
	constTypes[3] = (char*)"boolConst,";

	int j;

	for (int i = 0; i < T_const; i++)
	{
		j = 0;
		while (a[j] == constTypes[i][j])
		{
			j++;
		}
		if (j == strlen(constTypes[i]))
		{
			return i + 1;
		}
	}
	return 0;
}

// Action notation is: A_*				('.' * means action number).
bool syntax_analyzer(char* a)
{
	fstream ofstream;
	ofstream.open("syntax_input.txt", ios::app);
	ofstream << a << endl;
	ofstream.close();
	// It stores name of identifier used in source program.
	char id_name[20];

	// It stores type of input,
	// intConst, doubConst, strConst, boolConst
	// and zero for all Others  except NULL. 
	int constType = 0;
	constType = isConst(a);

	// It stores data of constant type.
	char* constData;
	constData = new char[strlen(a)];

	if ('i' == a[0] && 0 == constType)
	{
		if ('\0' != a[1] && 'd' == a[1])
		{
			str_copy(id_name, a, 3, strlen(a) - 3);
			a[2] = '\0';
		}
	}

	// Check if input is ConstType.
	else
	{
		switch (constType)
		{
		case 0:
			break;
		case 1:
			// Copy Constant data in another array.
			str_copy(constData, a, 9, strlen(a) - 9);
			a[8] = '\0';
			cout << "ConstInput, a: " << a << ", Data: " << constData << "." << endl;
			break;
		case 2:
			// Copy Constant data in another array.
			str_copy(constData, a, 10, strlen(a) - 10);
			a[9] = '\0';
			cout << "ConstInput, a: " << a << ", Data: " << constData << "." << endl;
			break;
		case 3:
			// Copy Constant data in another array.
			str_copy(constData, a, 9, strlen(a) - 9);
			a[8] = '\0';
			cout << "ConstInput, a: " << a << ", Data: " << constData << "." << endl;
			break;
		case 4:
			// Copy Constant data in another array.
			str_copy(constData, a, 10, strlen(a) - 10);
			a[9] = '\0';
			cout << "ConstInput, a: " << a << ", Data: " << constData << "." << endl;
			break;
		default:
			cout << "Default case of consType. Input is: " << a << endl;
			cout << "constType value is: " << constType << endl;
		}
	}

	char* pop_prod = NULL;				// Stores pop element from a stack to be replaced.
	int non_terminal_index;				// It stores index of non-Terminal which is replaced with a production.
	int terminal_index;					// It stores index of input Terminal in a parse table.
	char* push_prod = NULL;				// It stores production to be pushed in a stack.
	int stop_push = 0;					// It stores index to be pushed in a stack.
	int prod_len;						// It stores length of a production to be pushed in the stack.
	char* push_token;					// It stores topken to be pushed in the stack.
	int action_num = -1;				// It stores action number to be performed.

	while (true)
	{
		pop_prod = prod.top();
		prod.pop();

		cout << "Poped from top of a stack is: " << pop_prod << endl;
		if ('A' == pop_prod[0] && '_' == pop_prod[1])
		{
			// Action is poped from a stack.
			// Call specific function to perform an action.
			action_num = atoi(pop_prod + 2);
			cout << "Action is poped. It's num is: " << action_num << endl;
			cout << "Poped is: " << pop_prod << "." << endl;

			switch (action_num)
			{
			case 0:
				Action_0();
				break;
			case 1:
				Action_1();
				break;
			case 2:
				Action_2();
				break;
			case 3:
				Action_3();
				break;
			case 4:
				Action_4();
				break;
			case 5:
				Action_5();
				break;
			case 6:
				Action_6();
				break;
			case 7:
				Action_7();
				break;
			case 8:
				Action_8();
				break;
			case 9:
				Action_9();
				break;
			default:
				if (10 != action_num)
				{
					action_num -= 11;
					Action_11(action_num);
				}
			}
			continue;
		}

		// Below Statements are used in scope checking. 
		if (isEqual((char*)"Decl", pop_prod))
		{
			func_decl = true;
			semantic_temp = new semantic;
		}
		else if (isEqual((char*)"Variable", pop_prod) || isEqual((char*)"VariDecl", pop_prod))
		{
			variable_decl = true;
			semantic_temp = new semantic;
		}
		else if (isEqual((char*)"StmtBlk", pop_prod))
		{
			if (func_decl)
			{
				func_decl = false;
			}
			else initialize_scope();
		}

		// This statement is used in type checking.
		if (isEqual((char*)"StmtBlk", pop_prod) || isEqual((char*)";", pop_prod))
		{
			operator_check = false;
			prev_id_name[0] = '\0';

		}

		// If stack top of production is reached at terminal symbol.
		if (isTerminal(pop_prod))
		{
			// If production is Terminal It should match with Input.
			if (isEqual(pop_prod, a))
			{
				// Now  store symbol table information if it is declaration.
				// These operations are for scope Checking.
				if (variable_decl)
				{
					if (isEqual((char*)"id", a))
					{
						// Store name of declaration.
						semantic_temp->set_id(id_name);
						variable_decl = false;

						// Insert node at start of vecor.
						// Make sure, this variable is declared first time in this scope.
						// if (isVariDecl(symbol_table, semantic_temp))
						// It will be true if variable is used before declaration.
						if (isVariDecl(id_name, false))
						{
							cout << "This variable is already declared in this scope." << endl;
							cout << "Variable name is: " << semantic_temp->get_id() << endl;
						}
						else
						{
							symbol_table.insert(symbol_table.begin(), semantic_temp);
						}

						operator_check = false;
						prev_id_name[0] = '\0';
					}
					else
					{
						// Store type of declaration.
						semantic_temp->set_type(a);
					}
				}

				else if (func_decl)
				{
					if (isType(a))
					{
						semantic_temp->set_type(a);
					}
					else if (isEqual((char*)"id", a))
					{
						semantic_temp->set_id(id_name);
					}
					else if (isEqual((char*)";", a))
					{
						semantic_temp->set_func(false);

						// It will  be true if Variable is used before declaration.
						// Check this variable is declared in this scope.
						if (isVariDecl(id_name, false))
						{
							cout << "This variable is already declared in this scope." << endl;
							cout << "Variable name is: " << semantic_temp->get_id() << endl;
						}
						else
						{
							symbol_table.insert(symbol_table.begin(), semantic_temp);
						}
						operator_check = false;
						prev_id_name[0] = '\0';
					}
					else if (isEqual((char*)"(", a))
					{
						// It stores function declaration.
						semantic_temp->set_func(true);
						symbol_table.insert(symbol_table.begin(), semantic_temp);
						// It inserts delimeter of new scope.
						initialize_scope();
						operator_check = false;
						prev_id_name[0] = '\0';
					}
				}

				// Checks end of the scope.
				else if (isEqual((char*)"}", a))
				{
					// This function pops the recent scope uploaded.
					pop_recent_scope();

				}

				else if (isEqual((char*)"id", a))
				{
					// Check if identifier is used.
					// It will be true if variable is used before declaration.
					if (!isVariDecl(id_name, true))
					{
						cout << "This variable is used before declaration." << endl;
						cout << "Variable Name  is: " << id_name << endl;
					}
				}

				// These operations are for type checking.
				if (isEqual((char*)"id", a) && !operator_check)
				{
					operator_check = true;
					str_copy(prev_id_name, id_name, strlen(id_name));
				}
				else if (isEqual((char*)"id", a) && operator_check && strlen(prev_id_name) > 0)
				{
					// It is true if type mis match.
					if (!check_type(id_name, prev_id_name))
					{
						cout << "Type Mis Match: " << prev_id_name << endl;
						cout << "Type Mis Match: " << id_name << endl;
					}
				}
				else if (isConstant(a) && operator_check && strlen(prev_id_name) > 0)
				{
					// It will be true if type mis match occurs.
					if (!comp_type(prev_id_name, get_const_type(a)))
					{
						cout << "Type mis Match: " << prev_id_name << endl;
						cout << "Type mis Match: " << a << endl;
					}
				}

				if (isConstant(a))
				{
					Action_10(constData);
				}
				else if (a[0] == 'i' && a[1] == 'd' && isEqual(prod.top(), (char*)"A_10"))
				{
					prod.pop();
					Action_10(id_name);
				}
				cout << "Input is matched. It is: " << a << endl;
				return true;
			}
			else
			{
				cout << "Syntax Error.\n";
				cout << "Stack top is: " << pop_prod << endl;
				cout << "Input is: " << a << endl;
				cout << "Exiting a program...\n";
				system("pause");
				cout << "Now poping stack elements..." << endl;
				while (!prod.empty())
				{
					cout << prod.top() << endl;
					prod.pop();
				}
				cout << "Stack  is  empty..." << endl;
				stop_program = true;				// Stop execution of program.

				system("pause");
				exit(-1);
				return false;
			}

		}
		else if (isEqual(pop_prod, (char*)"epsilon"))
		{
			// Skip this epsilon.
			continue;
		}
		else
		{
			// Input detected is Non-Terminal.
			non_terminal_index = non_Terminal_index(pop_prod);

			// Find corresponding column/Terminal to replace this production.
			terminal_index = Terminal_index(a);

			// Now push production on a stack.
			push_prod = parse_table[non_terminal_index][terminal_index];
			if (NULL == push_prod)
			{
				cout << "Moving in wrong direction..." << endl;
				return false;
			}
			prod_len = strlen(push_prod);
			stop_push = prod_len;

			// Tokenizing production to push on a Stack.
			for (int j = prod_len - 1; j >= 0; j--)
			{
				if (' ' == push_prod[j])
				{
					push_token = new char[stop_push - j + 1];
					str_copy(push_token, push_prod, j + 1, stop_push - (j + 1));
					stop_push = j;
					prod.push(push_token);
				}
				else if (0 == j)
				{
					push_token = new char[stop_push - j];
					str_copy(push_token, push_prod, j, stop_push - j);
					prod.push(push_token);
					stop_push = j;
				}
			}
		}
	}

	return false;
}

// *******************************  Lexical Analyzer Functions  ******************************

// It copies size bytes from src to des.
bool str_copy(char* des, char* src, int size)
{
	int i = 0;
	for (; src[i] != '\0' && i < size; i++)
	{
		des[i] = src[i];
	}
	des[i] = '\0';
	return true;
}


// Initialization functions...
bool init_KeyWords()
{
	// It will initialize keyWords.
	keyWords = new char* [max_Token_length];
	keyWords[0] = (char*)"void";
	keyWords[1] = (char*)"int";
	keyWords[2] = (char*)"double";
	keyWords[3] = (char*)"bool";
	keyWords[4] = (char*)"string";
	keyWords[5] = (char*)"class";
	keyWords[6] = (char*)"interface";
	keyWords[7] = (char*)"null";
	keyWords[8] = (char*)"this";
	keyWords[9] = (char*)"extends";
	keyWords[10] = (char*)"implements";
	keyWords[11] = (char*)"for";
	keyWords[12] = (char*)"while";
	keyWords[13] = (char*)"if";
	keyWords[14] = (char*)"else";
	keyWords[15] = (char*)"return";
	keyWords[16] = (char*)"break";
	keyWords[17] = (char*)"New";
	keyWords[18] = (char*)"NewArray";
	keyWords[19] = (char*)"Print";
	keyWords[20] = (char*)"ReadInteger";
	keyWords[21] = (char*)"ReadLine";
	return true;
}

bool init_bool_constants()
{
	bool_constants = new char* [2];
	bool_constants[0] = (char*)"true";
	bool_constants[1] = (char*)"false";
	return true;
}

bool init_operators()
{
	operators = new char* [18];
	operators[0] = (char*)"+";
	operators[1] = (char*)"-";
	operators[2] = (char*)"*";
	operators[3] = (char*)"/";
	operators[4] = (char*)"%";
	// operators[5] = (char*) "<=";
	operators[5] = (char*)"<";
	// operators[7] = (char*) ">=";
	operators[6] = (char*)">";
	// operators[9] = (char*) "==";
	// operators[10] = (char*) "!=";
	operators[7] = (char*)"=";
	// operators[12] = (char*) "&&";
	// operators[13] = (char*) "||";
	operators[8] = (char*)"!";
	operators[9] = (char*)";";
	operators[10] = (char*)",";
	operators[11] = (char*)".";
	operators[12] = (char*)"[";
	operators[13] = (char*)"]";
	operators[14] = (char*)"(";
	operators[15] = (char*)")";
	operators[16] = (char*)"{";
	operators[17] = (char*)"}";
	return true;
}

// *******************    DFA functions.   ************************
// It returns true if input character is a digit [0 - 9].	
bool isNum(char a)
{
	if (a > 47 && a < 58)
	{
		return true;
	}
	else return false;
}

// It returns true if input character is an alphabet.
bool isLetter(char a)
{
	if ((a > 64 && a < 91) || (a > 96 && a < 123))
	{
		return true;
	}
	else return false;
}

int isDecimal(char* a)
{
	int i = 0;
	while (isNum(a[i]))
	{
		i++;
	}
	return i;
}

// It returns true if it is a Heximal digit.
int isHex(char* a)
{
	int i = 0;
	if (48 == a[0] && (88 == a[1] || 120 == a[1]) && isNum(a[3]))
	{
		i += 3;
		while (isNum(a[i]))
		{
			i++;
		}
		return i;
	}
	else return i;
}

bool isKeyword(char* a)
{
	for (int i = 0; i < max_Token_length; i++)
	{
		if (isEqual(a, keyWords[i]))
		{
			return true;
		}
	}
	return false;
}

bool isBool(char* a)
{
	for (int i = 0; i < 2; i++)
	{
		if (isEqual(a, bool_constants[i]))
		{
			return true;
		}
	}
	return false;
}

// Assuming total number of operators are 24, excluding "/*", "*/".
bool isOperator(char* a)
{
	int count = 0;
	for (int i = 0; i < 18; i++)
	{
		if (a[0] == operators[i][0])
		{
			// Operator matched.
			if ('<' == a[0] || '>' == a[0] || '!' == a[0] || '=' == a[0])
			{
				if ('=' == a[1])
				{
					count += 2;
					break;
				}
				else
				{
					count++;
					break;
				}
			}
			count++;
			break;
		}
	}
	if (('&' == a[0] && '&' == a[1]) || ('|' == a[0] && '|' == a[1]))
	{
		count += 2;
	}

	if (count)
	{
		char* temp = new char[count];
		str_copy(temp, a, count);
		WriteFile(tokens, temp, strlen(temp), NULL, 0);
		WriteFile(tokens, (LPVOID)"\n", 1, NULL, 0);
		fileLocation += (count - 1);

		if (!syntax_analyzer(temp))
		{
			cout << "Your input is not syntatically correct...Operators" << endl;
			system("pause");
			exit(-1);
		}
		return true;
	}
	else return false;
}

int isDouble(char* a)
{
	int i = 0;
	if ('.' == a[i])
	{
		i++;
		while (isNum(a[i]))
		{
			i++;
		}
		if ('E' == a[i])
		{
			i++;
			if ('+' == a[i] || '-' == a[i])
			{
				i++;
			}
			if (isNum(a[i]))
			{
				i++;
				while (isNum(a[i]))
				{
					i++;
				}

				return i;
			}
			// It is an error or Not accepted by double.
			else return 0;
		}
		return i;
	}
	else return i;
}

bool identifier_check(char a)
{
	if (isNum(a) || isLetter(a) || '_' == a)
	{
		return true;
	}
	else return false;
}

// It will identify identifier pattern and than identify keyword, bool or identifier.
void kb_id(char* a)
{
	int i = 0;
	while (identifier_check(*(a + i)))
	{
		i++;
	}
	// It stores identifier, keyword and bool constant.
	char* raw_identifier = new char[i];

	// It copies identifier.
	str_copy(raw_identifier, a, i);
	if (isKeyword(raw_identifier))
	{
		WriteFile(tokens, "<keyword,", 9, NULL, 0);
		WriteFile(tokens, raw_identifier, i, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);

		// Now call a syntax analyzer to match corresponding input...
		if (!syntax_analyzer(raw_identifier))
		{
			cout << "Your input is not syntatically correct... Kb_id_keyword" << endl;
			system("pause");
			exit(-1);
		}
	}
	else if (isBool(raw_identifier))
	{
		// Bool identifier.
		WriteFile(tokens, "<bool,", 6, NULL, 0);
		WriteFile(tokens, raw_identifier, i, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);

		int lenSyntaxInput = 11 + strlen(raw_identifier);
		char* syntaxInput = new char[lenSyntaxInput];
		strcpy_s(syntaxInput, lenSyntaxInput, "boolConst,\0");
		strcat_s(syntaxInput, lenSyntaxInput, raw_identifier);

		if (!syntax_analyzer(syntaxInput))
		{
			cout << "Your input is not syntatically correct... kb_id_bool" << endl;
			system("pause");
			exit(-1);
		}
	}
	else
	{
		// Identifier is accepted.
		WriteFile(tokens, "<id,", 4, NULL, 0);
		WriteFile(tokens, raw_identifier, i, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);
		WriteFile(identifiers, raw_identifier, i, NULL, 0);
		WriteFile(identifiers, "\n", 1, NULL, 0);

		char semantic_input[25];
		semantic_input[0] = 'i';
		semantic_input[1] = 'd';
		semantic_input[2] = ',';
		str_copy((semantic_input + 3), raw_identifier, strlen(raw_identifier));
		if (!syntax_analyzer(semantic_input))
		{
			cout << "Your input is not syntatically correct... kb_id_identifier" << endl;
			system("pause");
			exit(-1);
		}
	}

	fileLocation += (i - 1);
	/*
	cout << "kb_id, Freeing memory..." << endl;
	delete[] raw_identifier;
	cout << "kb_id, memory is freed..." << endl;
*/

	return;
}

void numeric(char* a)
{
	int i = fileLocation;
	int ret_fun = 0;

	ret_fun = isHex(a);
	if (ret_fun)
	{
		char* temp = new char[ret_fun];
		str_copy(temp, a, ret_fun);
		WriteFile(tokens, "<hex,", 5, NULL, 0);
		WriteFile(tokens, temp, ret_fun, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);
		fileLocation += (ret_fun - 1);

		int lenSyntaxInput = 10 + strlen(temp);
		// char* syntaxInput = new char[strlen(temp) + 9];
		char* syntaxInput = new char[lenSyntaxInput];
		strcpy_s(syntaxInput, lenSyntaxInput, "intConst,\0");
		strcat_s(syntaxInput, lenSyntaxInput, temp);

		if (!syntax_analyzer(syntaxInput))
		{
			cout << "Your input is not syntatically correct... numeric_hex" << endl;
			cout << "Input to syntax is: " << syntaxInput << endl;
			system("pause");
			exit(-1);
		}
		return;
	}
	ret_fun = isDecimal(a);
	if (ret_fun)
	{
		int deci_val = ret_fun;
		ret_fun = isDouble((a + deci_val));
		if (ret_fun)
		{
			ret_fun += deci_val;
			char* temp = new char[ret_fun];
			str_copy(temp, a, ret_fun);
			WriteFile(tokens, "<double,", 8, NULL, 0);
			WriteFile(tokens, temp, ret_fun, NULL, 0);
			WriteFile(tokens, ">\n", 2, NULL, 0);

			// It stores size of array to be declared dynamically.
			int lenSyntaxInput = 11 + strlen(temp);
			char* syntaxInput = new char[lenSyntaxInput];
			strcpy_s(syntaxInput, lenSyntaxInput, (char*)"doubConst,\0");
			strcat_s(syntaxInput, lenSyntaxInput, temp);

			if (!syntax_analyzer(syntaxInput))
			{
				cout << "Your input is not syntatically correct...numeric_double" << endl;
				system("pause");
				exit(-1);
			}
		}
		else
		{
			ret_fun = deci_val;
			char* temp = new char[ret_fun];
			str_copy(temp, a, ret_fun);
			WriteFile(tokens, "<decimal,", 9, NULL, 0);
			WriteFile(tokens, temp, ret_fun, NULL, 0);
			WriteFile(tokens, ">\n", 2, NULL, 0);

			// It stores size of array to be declared dynamically.
			int lenSyntaxInput = 10 + strlen(temp);
			char* syntaxInput = new char[lenSyntaxInput];
			strcpy_s(syntaxInput, lenSyntaxInput, "intConst,\0");
			strcat_s(syntaxInput, lenSyntaxInput, temp);

			if (!syntax_analyzer(syntaxInput))
			{
				cout << "Your input is not syntatically correct... numeric_decimal" << endl;
				cout << "Input to syntax Analyzer is:" << syntaxInput << "." << endl;
				system("pause");
				exit(-1);
			}
		}
		fileLocation += (ret_fun - 1);
	}
	return;
}

bool isString(char* a)
{
	int i = 0;
	if (34 == a[i])
	{
		i++;
		while (a[i] != 34)
		{
			i++;
		}
		char* temp = new char[i];
		str_copy(temp, (a + 1), i - 1);
		WriteFile(tokens, "<str,", 5, NULL, 0);
		WriteFile(tokens, temp, i - 1, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);

		int lenSyntaxInput = strlen(temp) + 10;
		char* syntaxInput = new char[lenSyntaxInput];

		// strcpy_s(syntaxInput, )
		strcpy_s(syntaxInput, lenSyntaxInput, (char*)"strConst,\0");
		strcat_s(syntaxInput, lenSyntaxInput, temp);

		// if (syntax_analyzer((char*)"strConst"))
		if (!syntax_analyzer(syntaxInput))
		{
			cout << "Your input is not syntatically correct...isString" << endl;
			system("pause");
			exit(-1);
		}
		fileLocation += i;
		return true;
	}
	else return false;
}

bool isComment(char* a)
{
	int i = 0;
	if ('/' == a[i])
	{
		i++;
		if ('/' == a[i]) // One line comment.
		{
			i++;
			while ('\n' != a[i])
			{
				i++;
			}
			char* temp = new char[i];
			str_copy(temp, (a), i - 1);
			// cout << "Single line comment is accepted: " << temp << endl;
			fileLocation += i;
			return true;
		}
		// Multi line comments.
		else if ('*' == a[i])
		{
			i++;
			while (true)
			{
				if ('*' == a[i] && '/' == a[i + 1])
				{
					i++;
					break;
				}
				i++;
			}
			char* temp = new char[i];
			str_copy(temp, (a), i);
			fileLocation += i;
			return true;
		}
		else return false;
	}
	else return false;
}

char* parser()
{
	// It stores string to be returned, max length of identifer is 31.
	char a[32];
	int start = fileLocation;
	int op_ret;
	op_ret = isOperator((filePointer + fileLocation)); // This line is incomplete, it will be updated.

	while ((filePointer[fileLocation] != '\n') && (filePointer[fileLocation] != '\t') \
		&& (filePointer[fileLocation] != '"') && !isOperator(filePointer + fileLocation) \
		&& (filePointer[fileLocation] != ' '))
	{
		fileLocation++;
	}
	str_copy(a, (filePointer + start), 0, (fileLocation - start));
	return a;
}

int main()
{

	// Mapping file into a memory...
	HANDLE open;						// It stores Handle of a code file.
	LPCSTR name = "scope.txt";			// Name of a code file.
	HANDLE mem;							// Stores the handle of Memory mapping.
	DWORD f_size;						// Stores size of a file.
	char* test;							// It stores input file.

	open = CreateFileA(name, GENERIC_WRITE | GENERIC_READ, FILE_READ_ACCESS, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (open == INVALID_HANDLE_VALUE)
	{
		cout << "Error in reading a file. Code is: " << GetLastError() << endl;
		return -1;
	}
	else
	{
		f_size = GetFileSize(open, 0);
		if (f_size == 0xFFFFFFFF && GetLastError() != 0)
			cout << "Error in getting size of " << name << ". Error is: " << GetLastError() << endl;
		mem = CreateFileMappingA(open, NULL, PAGE_READONLY, 0, f_size, 0);
		if (mem == NULL)
		{
			cout << "Error in creating FileMapping of: " << name << ". Error is: " << GetLastError() << endl;
			// system("pause");
			return -1;
		}

		test = (char*)MapViewOfFile(mem, FILE_MAP_READ, 0, 0, f_size);
		if (test == NULL)
		{
			cout << "Error in creating MapView of: " << name << ". Error is: " << GetLastError() << endl;
			return -1;
		}
	}

	// Creating files for Tokens and Identifer.
	tokens = CreateFileA("words.txt", GENERIC_WRITE, FILE_READ_ACCESS, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (INVALID_HANDLE_VALUE == tokens)
	{
		cout << "Error in Creating a words.txt file. Code is: " << GetLastError() << endl;
		return -1;
	}

	identifiers = CreateFileA("tabels.txt", GENERIC_WRITE, FILE_READ_ACCESS, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (INVALID_HANDLE_VALUE == identifiers)
	{
		cout << "Error in Creating a tabels.txt file. Code is: " << GetLastError() << endl;
		return -1;
	}
	// It will save Intermediate code generated using this code.
	code_file = CreateFileA("intermediate_code.txt", GENERIC_WRITE, FILE_READ_ACCESS, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (INVALID_HANDLE_VALUE == code_file)
	{
		cout << "Error in Creating a tabels.txt file. Code is: " << GetLastError() << endl;
		return -1;
	}

	init_KeyWords();
	init_bool_constants();
	init_operators();
	init_parse();
	// init_Action();
	fileLocation = 0;

	for (; (test[fileLocation] != 0); fileLocation++)
	{
		if (isLetter(test[fileLocation]))
		{
			kb_id((test + fileLocation));	// It will identify identifier pattern and than identify keyword, bool or identifier.
		}
		else if (isNum(test[fileLocation]))
		{
			numeric((test + fileLocation));
		}
		else if (isString(test + fileLocation))
		{
			// cout << "main isString, Input in else is: " << test[fileLocation] << endl;
		}
		else if (isComment(test + fileLocation))
		{
			// cout <<"Comment is accepted." << endl; 
		}
		else if (isOperator(test + fileLocation))
		{
			// cout << "operator is accepted..." << endl;
		}
		else
		{
			// cout << "Input in else is: " << test[fileLocation] << endl;
		}
		if (stop_program)
		{
			cout << "Program is going to be terminated." << endl;
			return -1;
		}
	}
	if ('\0' == test[fileLocation])
	{
		cout << "Input is finished..." << endl;
		if (!syntax_analyzer((char*)"$"))
		{
			cout << "Syntax of a code is not correct..." << endl;
			system("pause");
			return -1;
		}
	}

	UnmapViewOfFile(test);						// Free memory from MapView.
	CloseHandle(mem);							// Closing Handle of CreateFileMapping.
	CloseHandle(tokens);
	CloseHandle(identifiers);

	cout << "Progarm has finished job sucessfully." << endl;
	system("pause");
	return 0;
}
