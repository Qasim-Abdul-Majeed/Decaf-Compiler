#include <iostream>
#include "windows.h"
#include <fstream>
#include <stack>
#include <queue>
#include <vector>
#include <map>

using namespace std;

bool str_copy(char* des, char* source, int len);

//Defining DataStructures.
class semantic
{
	char type[10];							//It stores type of identifier.
	char id[22];							//It stores name of identifier.
	bool func;						//It is Ture if function is declared.
public:
	semantic()
	{
		//*type = NULL;
		//*id = NULL;
		type[0] = '\0';
		id[0] = '\0';
		func = false;
	}
	void set_type(char* a)
	{
		str_copy(type, a, strlen(a));
	}
	void set_id(char* a)
	{
		str_copy(id, a, strlen(a));
	}
	void set_func(bool a) { func = a; }

	char* get_type() { return type; }
	char* get_id() { return id; };
	bool is_func() { return func; }
};

//Defining Global variables e.g keywords, bool etc.

//Maximum length a token can have.
#define max_Token_length 22

//keyWords are pointed using this.
char** keyWords;

//bool constants are pointed using this.
char** bool_constants;

//Operators are pointed using this.
char** operators;

//It will point to memory map of a file.
char* filePointer;

//It will point to current location of a file. 
int fileLocation;

//Handle of files for tookens and identifier...
HANDLE tokens, identifiers;

//Char input for a Parser...
char parse_input[10];
//It maintains stack for productions.
stack<char*> prod;

//It stores parse table.
char* parse_table[35][35];

//It stores rows name of a parse table, which are non-Terminals.
char* parse_row[35];

//It stores cols name of a parse  table, which are Terminals.
char* parse_col[35];

//Total number of Terminals.
int Terminals = 35;

//Total number of  non-Terminals.
int non_Terminals = 35;

//It is true if syntax is not correct.
bool stop_program = false;

//It stores semantic information temporarily.
semantic* semantic_temp;						

//It stores variable declaritions of a program.
vector<semantic*> symbol_table;					


//It is true if Variable Declaration is performed.
bool variable_decl = false;						

//It is true if Function Declaration is performed.
bool func_decl = false;							

//It will set on id arrival.
bool operator_check = false;					

//It stores previous identifier for type checking.
char prev_id_name[25];

//It is used in get_const_type.
char get_type[10];

//It stores identifiers and constants to help in intermediate Code generation.
stack <char*> id_stack;

//It stores queues to generate labels in intermediate code generation.
//It helps in ifStmt labels.
stack<queue<int>*> labels_stack;

//It stores labels count generated upto now.
int labelCount = 0;					


//It stores register number has been used.
int registerCount = 0;

//It is used for filing of intermedite code generation.
HANDLE code_file;

//Map Actions to a char**.
typedef void (*Action_Num)();
map<char*, Action_Num> ActionMap;

//*********************Defining functions**********************



//It will perform an action A0 of grammer. 
//New queue, increment labelCount, Write in a file.
//LabelCount value is used first and than incremented for use afterwards.
void Action_0()
{
	//It stores code to be written in a file.
	char code[60];
	//Initializing code array as an empty array.
	code[0] = '\0';

	//It stores number in a char*.
	char num[10];
	//Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	queue<int>* a = new queue<int>;
	labels_stack.push(a);			//Push this queue in a stack.

	//cout << "Length of code  array is: " << strlen(code) << endl;

	//Saving code in a char array.
	strcat_s(code, (char*)"if R");
	//Convert Register Number in char*
	_itoa_s(registerCount - 1, num, 10);
	//Concat code upto now.
	strcat_s(code, num);

	//Now code of First label.
	strcat_s(code, (char*)" goto L");
	//convert labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);
	//Enqueue labelCount in queue. 
	a->push(labelCount);
	//Increment labelCount for Second label.
	labelCount++;

	strcat_s(code, (char*)"\ngoto L");
	//convert labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);
	//Enqueue labelCount in a queue.
	a->push(labelCount);
	labelCount++;

	//Now start point of first label.
	strcat_s(code, (char*)"\nL");
	_itoa_s(a->front(), num, 10);
	//Now dequeue Label, which has been used.
	a->pop();
	strcat_s(code, num);
	strcat_s(code, (char*)":\n");
	//Intermediate Code has to generated by this function is present in code array.
	//Now writting this code in a file.
	WriteFile(code_file, code, strlen(code), NULL, NULL);
	cout << "Code generated by Action_0 has been written in file. Its length is: " << strlen(code) << endl;
}

//It checks queue on top of labels stack should be empty. pop that queue.
//It will place a label where if statement ends. 
void Action_1()
{
	//It stores to be generated by this function.
	char code[20];
	//Initialize code array as an empty array.
	code[0] = '\0';
	//It stores labelCount in char*.
	char num[10];
	//Initialize num array as an empty array.
	num[0] = '\0';

	strcat_s(code, (char*)"L");
	//Stores labelCount in char*.
	_itoa_s(labels_stack.top()->front(), num, 10);
	strcat_s(code, num);
	//Dequeue labelCount which has been used.
	labels_stack.top()->pop();
	strcat_s(code, (char*)":\n");

	if (labels_stack.top()->empty())
	{
		cout << "Action_1: Queue is empty." << endl;
		labels_stack.pop();
	}
	else
	{
		cout << "Action_1: Queue is not empty. Still poping it..." << endl;
		system("pause");
		labels_stack.pop();
	}
	WriteFile(code_file, code, strlen(code), NULL, NULL);
	cout << "Code generated by Action_1 has been written in file. Its length is: " << strlen(code) << endl;
}

//It will be called when else statment is declared.
//It will enqueue 
void Action_2()
{
	//It stores code to be written in a file.
	char code[20];
	//Initializing code array as an empty array.
	code[0] = '\0';

	//It stores number in a char*.
	char num[10];
	//Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	//Concat code.
	strcat_s(code, (char*)"goto L");
	//Save labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, (char*)num);
	//Insert new labelCount in a queue at top of a stack. Induced because of Else statement.
	labels_stack.top()->push(labelCount);

	//Now label for else statement.
	strcat_s(code, (char*)"\nL");
	//Store labelNumber of else statement in char*.
	_itoa_s(labels_stack.top()->front(), num, 10);
	//Dequeue labelCount that has been used.
	labels_stack.top()->pop();

	strcat_s(code, num);
	strcat_s(code, (char*)":\n");

	WriteFile(code_file, code, strlen(code), NULL, NULL);
	cout << "Code generated by Action_2 has been written in file. Its length is: " << strlen(code) << endl;
}

//It will perform Wh_St action, named as A_3
void Action_3()
{
	//It stores code to be written in a file.
	char code[20];
	//Initializing code array as an empty array.
	code[0] = '\0';

	//It stores number in a char*.
	char num[10];
	//Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	//New queue for every while statement.
	queue<int>* a = new queue<int>;

	//Push this queue in a stack.
	labels_stack.push(a);			

	strcat_s(code, (char*)"L");
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);
	labelCount++;
	strcat_s(code, (char*)":\n");

	WriteFile(code_file, code, strlen(code), NULL, NULL);
	cout << "Code generated by Action_3 has been written in file. Its length is: " << strlen(code) << endl;
}

void Action_4()
{
	//It stores code to be written in a file.
	char code[60];
	//Initializing code array as an empty array.
	code[0] = '\0';

	//It stores number in a char*.
	char num[10];
	//Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	queue<int>* a = labels_stack.top();

	//cout << "Length of code  array is: " << strlen(code) << endl;

	//Saving code in a char array.
	strcat_s(code, (char*)"if R");
	//Convert Register Number in char*
	_itoa_s(registerCount - 1, num, 10);
	//Concat code upto now.
	strcat_s(code, num);

	//Now code of First label.
	strcat_s(code, (char*)" goto L");
	//convert labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);
	//Enqueue labelCount in queue. 
	a->push(labelCount);
	//Increment labelCount for Second label.
	labelCount++;

	strcat_s(code, (char*)"\ngoto L");
	//convert labelCount in char*
	_itoa_s(labelCount, num, 10);
	strcat_s(code, num);
	//Enqueue labelCount in a queue.
	a->push(labelCount);
	labelCount++;

	//Now start point of first label.
	strcat_s(code, (char*)"\nL");
	_itoa_s(a->front(), num, 10);
	//Now dequeue Label, which has been used.
	a->pop();
	strcat_s(code, num);
	strcat_s(code, (char*)":\n");
	//Intermediate Code has to generated by this function is present in code array.
	//Now writting this code in a file.
	WriteFile(code_file, code, strlen(code), NULL, NULL);
	cout << "Code generated by Action_4 has been written in file. Its length is: " << strlen(code) << endl;
}

void Action_5()
{
	//It stores to be generated by this function.
	char code[20];
	//Initialize code array as an empty array.
	code[0] = '\0';
	//It stores labelCount in char*.
	char num[10];
	//Initialize num array as an empty array.
	num[0] = '\0';

	strcat_s(code, (char*)"goto L");
	//Stores labelCount where jump is to be placed in char*.
	_itoa_s(labels_stack.top()->front() - 2, num, 10);
	strcat_s(code, num);

	strcat_s(code, (char*)"\nL");
	//Stores labelCount in char*.
	_itoa_s(labels_stack.top()->front(), num, 10);
	strcat_s(code, num);
	//Dequeue labelCount which has been used.
	labels_stack.top()->pop();

	strcat_s(code, (char*)":\n");

	if (labels_stack.top()->empty())
	{
		cout << "Action_5: Queue is empty." << endl;
		labels_stack.pop();
	}
	else
	{
		cout << "Action_5: Queue is not empty. Still poping it..." << endl;
		system("pause");
		labels_stack.pop();
	}
	WriteFile(code_file, code, strlen(code), NULL, NULL);
	cout << "Code generated by Action_5 has been written in file. Its length is: " << strlen(code) << endl;
}

void Action_6()
{
	WriteFile(code_file, "ret\n", 4, NULL, NULL);
}

void Action_7()
{
	cout << "Should I implement it?" << endl;
}

//It will be called on actuals arrival.
//It will pop recent identifier pushed on a stack.
void Action_8()
{
	id_stack.pop();
}

//It implements action of an assignment operator.
void Action_9()
{
	//It stores code to be written in a file.
	char code[60];
	//Initializing code array as an empty array.
	code[0] = '\0';

	//It stores number in a char*.
	char num[10];
	//Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	//It stores name of identifier which is left side of an equation.
	//char assign_id[25];
	//assign_id[0] = '\0';

	//It stores name of identifier which should be on right side of an equation.
	char* assign_id;
	//assign_id[0] = '\0';

	assign_id = id_stack.top();
	id_stack.pop();
	//strcat_s(code, assign_id);
	//strcat_s(code, " = ");
	//strcat_s(code, (char*)"R");
	//Use a register.
	//_itoa_s(registerCount++, num, 10);
	//registerCount++;

	//strcat_s(code, num);
	//strcat_s(code, " = ");

	//Assignment will always be at top of id_stack.
	strcat_s(code, id_stack.top());
	//Now pop element at top of stack.
	id_stack.pop();

	//Place an equal operator in assignment operation.
	strcat_s(code, " = ");
	//Place right side of an assignment operation.
	strcat_s(code, assign_id);
	//strcat_s(code, (char*)" = R");

	//Last registerNumber has been used before calling this function.
	//_itoa_s(registerCount - 2, num, 10);
	//strcat_s(code, num);
	//code[strlen(code)] = '\n';
	strcat_s(code, (char*)"\n");

	WriteFile(code_file, code, strlen(code), NULL, NULL);
	cout << "Code generated by Action_9 has been written in file. Its length is: " << strlen(code) << endl;
	//system("pause");
}

//It will push identifier on a stack of Identifiers.
void Action_10(char* a)
{
	char* push = new char[strlen(a) + 1];
	strcpy_s(push, strlen(a) + 1, a);
	id_stack.push(push);
	cout << "Action_10: ";
	cout << "id_stack top is: " << id_stack.top() << endl;
}

//It will implement actions of Expression operators.
//Pop last 02 operands, place operator between them and assign to register.
void Action_11(int a)
{
	//It stores code to be written in a file.
	char code[60];
	//Initializing code array as an empty array.
	code[0] = '\0';

	//It stores number in a char*.
	char num[10];
	//Initializing num array as an empty array. It is ok without this one too.
	num[0] = '\0';

	//It stores register to be pushed on stack which stores result of this operation.
	char* reg_push = new char[10];
	reg_push[0] = '\0';

	//It stores right operand of an operator.
	char* right_operand;

	//Assignment of result to a new register.
	strcat_s(code, (char*)"R");
	_itoa_s(registerCount++, num, 10);
	strcat_s(code, num);

	//strcat_s(reg_push, (char*)"R");
	strcat_s(reg_push, 10, code);
	//Check is it working properly.

	strcat_s(code, (char*)" = ");

	right_operand = id_stack.top();
	id_stack.pop();

	//Place Left operand of an operator in code array.
	strcat_s(code, id_stack.top());
	id_stack.pop();

	//Now decide which operation has to be implemented.
	//...
	//map a to a specific switch.
	//a -= 11;
	switch (a)
	{
	case 0:
		strcat_s(code, (char*)" || ");
		break;
	case 1:
		strcat_s(code, (char*)" && ");
		break;
	case 2:
		strcat_s(code, (char*)" == ");
		break;
	case 3:
		strcat_s(code, (char*)" != ");
		break;
	case 4:
		strcat_s(code, (char*)" < ");
		break;
	case 5:
		strcat_s(code, (char*)" > ");
		break;
	case 6:
		strcat_s(code, (char*)" <= ");
		break;
	case 7:
		strcat_s(code, (char*)" >= ");
		break;
	case 8:
		strcat_s(code, (char*)" + ");
		break;
	case 9:
		strcat_s(code, (char*)" - ");
		break;
	case 10:
		strcat_s(code, (char*)" * ");
		break;
	case 11:
		strcat_s(code, (char*)" / ");
		break;
	case 12:
		strcat_s(code, (char*)" % ");
		break;
	}

	strcat_s(code, right_operand);
	//strcat_s(code, id_stack.top());
	//id_stack.pop();
	strcat_s(code, (char*)"\n");

	//Now push register on stack which stores results of this operation.
	id_stack.push(reg_push);

	//DWORD err = WriteFile(code_file, code, strlen(code), NULL, NULL);
	//if (0 == err)
	if(0 == WriteFile(code_file, code, strlen(code), NULL, NULL))
	{
		cout << "Error in writing file from Action_11. Error code: " << GetLastError() << endl;
	}
	cout << "Code generated by Action_11 has been written in file. Its length is: " << strlen(code) << endl;
	cout << "\n\n\n";
	cout << "Code generated by ths is: " << code << endl;
	cout << "\n\n\n\n";
	//system("pause");
	//cout << code << "." << endl;
}

void choteActions(int a)
{
	//It will Perform all actions.
	//For time being, it will implement ifStmt, ifStmt', wh_St.
	//Finally expr....


	switch (a)
	{
	case 0:
		Action_0();
		break;

	case 1:
		//Action_1();
		break;

	case 2:
		//whileAction();
		break;

	case 3:
		cout << "Expressions are need to be done." << endl;

	}

}


//It creates mapping of All actions.
//Except Action_8 and Action_11.
void init_Action()
{
	ActionMap[(char*)"A_0"] = Action_0;
	ActionMap[(char*)"A_1"] = Action_1;
	ActionMap[(char*)"A_2"] = Action_2;
	ActionMap[(char*)"A_3"] = Action_3;
	ActionMap[(char*)"A_4"] = Action_4;
	ActionMap[(char*)"A_5"] = Action_5;
	ActionMap[(char*)"A_6"] = Action_6;
	ActionMap[(char*)"A_7"] = Action_7;
	ActionMap[(char*)"A_9"] = Action_9;
	//ActionMap[(char*)"A_10"] = Action_10;
	ActionMap[(char*)"A_8"] = Action_8;
}


bool isEqual(char* a, char* b)
{
	//It returns true if both arrays are equal.
	//cout << "isEqual, a:" << a << "b:" << b << endl;
	int i = 0;
	while (a[i] == b[i] && a[i] != '\0' && b[i] != '\0')
	{
		i++;
	}
	//i--;
	if (a[i] == b[i])
	{
		///cout << "From isEqual: " << a[i] << "..." << b[i] << "a: " << a << " b: " << b << endl;
		return true;
	}
	else return false;

}

bool isConstant(char* a)
{
	if (isEqual(a, (char*)"intConst"))
		return true;
	else if (isEqual(a, (char*)"doubConst"))
		return true;
	else if (isEqual(a, (char*)"strConst"))
		return true;
	else if (isEqual(a, (char*)"boolConst"))
		return true;

	return false;
}

bool isVariDecl(char* a, bool use)
{
	//It returns if variable is already declared.
	//Use = true, if whole stack is need to be searched for declaration.
	//It checks wether the variable is already declared in this scope or not.
	//Use check search the whole list for search of variable declaration.
	for (int i = 0; i < symbol_table.size(); i++)
	{
		//cout << "Symbol table entity name: " << symbol_table.at(i)->get_id() << endl;
		//system("pause");
		//if (isEqual(symbol_table.at(i)->get_type(), (char*)"new") && !use) //Checks New scope is started.

		if (isEqual(symbol_table.at(i)->get_type(), (char*)"new") && !use) //Checks New scope is started.
		{
			break;
		}
		if (isEqual(symbol_table.at(i)->get_id(), a))
			return true;
	}
	return false;
}

bool isType(char* a)
{
	if (isEqual(a, (char*)"bool") || \
		isEqual(a, (char*)"string") || \
		isEqual(a, (char*)"int") || \
		isEqual(a, (char*)"double") || \
		isEqual(a, (char*)"float"))
	{
		return true;
	}
	else false;
}

bool initialize_scope()
{
	//It inserts a delemiter in symbol table for new scope.
	semantic_temp = new semantic;
	semantic_temp->set_type((char*)"new");
	semantic_temp->set_id((char*)"new");
	symbol_table.insert(symbol_table.begin(), semantic_temp);

	return true;

}

bool pop_recent_scope()
{
	//It removes most recent uploaded scope.
	while (!isEqual((char*)"new", symbol_table.front()->get_type()))
	{
		symbol_table.erase(symbol_table.begin());
	}
	symbol_table.erase(symbol_table.begin());

	return true;
}

bool check_type(char* a, char* b)
{
	char type_a[10];
	char type_b[10];
	for (int i = 0; i < symbol_table.size(); i++)
	{
		if (isEqual(symbol_table.at(i)->get_id(), a))
			str_copy(type_a, symbol_table.at(i)->get_type(), strlen(a));
		else if (isEqual(symbol_table.at(i)->get_id(), b))
			str_copy(type_b, symbol_table.at(i)->get_type(), strlen(b));
	}
	if (isEqual(type_a, type_b))
		return true;
	else return false;
}

bool comp_type(char* var, char* type)
{

	//cout << "Input of comp_type is: " << endl;
	//cout << "Var: " << var << ". Type: " << type << "." << endl;

	char type_a[10];
	for (int i = 0; i < symbol_table.size(); i++)
	{
		if (isEqual(symbol_table.at(i)->get_id(), var))
		{
			//str_copy(type_a, symbol_table.at(i)->get_type(), strlen(var));
			strcpy_s(type_a, symbol_table.at(i)->get_type());
			break;
		}
	}

	//cout << "Type of var extracted: " << type_a << endl;

	if (isEqual(type_a, type))
		return true;
	else return false;


}

char* get_const_type(char* a)
{
	//char type[10];

	if (isEqual(a, (char*)"intConst"))
		str_copy(get_type, (char*)"int", 3);
	else if (isEqual(a, (char*)"doubConst"))
		str_copy(get_type, (char*)"float", 5);
	else if (isEqual(a, (char*)"strConst"))
		str_copy(get_type, (char*)"string", 6);
	else if (isEqual(a, (char*)"boolConst"))
		str_copy(get_type, (char*)"bool", 4);


	//cout << "Input of get_Const_type: " << a << endl;
	//cout << "Output of get_Const_type: " << get_type << endl;

	return get_type;
}

char* get_type_name(char* a)
{

	char type_a[10];
	for (int i = 0; i < symbol_table.size(); i++)
	{
		if (isEqual(symbol_table.at(i)->get_id(), a))
		{
			str_copy(type_a, symbol_table.at(i)->get_type(), strlen(a));
			break;
		}
	}
	//if (isEqual(type_a, type))
	//	return true;
	//else return false;
	return type_a;

}

void print_symbol_table()
{

	cout << "\n\n***Printing Symbol Table***" << endl;
	for (int i = 0; i < symbol_table.size(); i++)
	{
		cout << "Id: " << symbol_table.at(i)->get_id() << ". Type: " << symbol_table.at(i)->get_type() << endl;
	}
	system("pause");
	cout << "***End of Symbol Table.***" << endl << endl;
}


//Syntax Analyzer Functions...
//Now Syntax Functions...
void init_parse()
{
	//Initializing Stack.
	prod.push((char*)"$");
	prod.push((char*)"Prog");

	//Initializing Terminals...
	parse_row[0] = (char*)"Prog";
	parse_row[1] = (char*)"Prog'";
	parse_row[2] = (char*)"Decl";
	parse_row[3] = (char*)"Decl'";
	parse_row[4] = (char*)"VariDecl";
	parse_row[5] = (char*)"Variable";
	parse_row[6] = (char*)"Type";
	parse_row[7] = (char*)"Formals";
	parse_row[8] = (char*)"Formals'";
	parse_row[9] = (char*)"StmtBlk";
	parse_row[10] = (char*)"StmtBa'";
	parse_row[11] = (char*)"StmtBb'";
	parse_row[12] = (char*)"Stmt";
	parse_row[13] = (char*)"IfStmt";
	parse_row[14] = (char*)"IfStmt'";
	parse_row[15] = (char*)"Wh_St";
	parse_row[16] = (char*)"Ret_St";
	parse_row[17] = (char*)"Ret_St'";
	parse_row[18] = (char*)"Actuals";
	parse_row[19] = (char*)"Actuals'";
	parse_row[20] = (char*)"Const";
	parse_row[21] = (char*)"Expr";
	parse_row[22] = (char*)"A'";
	parse_row[23] = (char*)"B";
	parse_row[24] = (char*)"B'";
	parse_row[25] = (char*)"C";
	parse_row[26] = (char*)"C'";
	parse_row[27] = (char*)"D";
	parse_row[28] = (char*)"D'";
	parse_row[29] = (char*)"E";
	parse_row[30] = (char*)"E'";
	parse_row[31] = (char*)"F";
	parse_row[32] = (char*)"F'";
	parse_row[33] = (char*)"G";
	parse_row[34] = (char*)"G'";

	//Initializing Non-Terminals.
	parse_col[0] = (char*)"int";
	parse_col[1] = (char*)"double";
	parse_col[2] = (char*)"bool";
	parse_col[3] = (char*)"string";
	parse_col[4] = (char*)";";
	parse_col[5] = (char*)"(";
	parse_col[6] = (char*)",";
	parse_col[7] = (char*)"{";
	parse_col[8] = (char*)"if";
	parse_col[9] = (char*)"while";
	parse_col[10] = (char*)"return";
	parse_col[11] = (char*)"id";
	parse_col[12] = (char*)"intConst";
	parse_col[13] = (char*)"doubConst";
	parse_col[14] = (char*)"boolConst";
	parse_col[15] = (char*)"strConst";
	parse_col[16] = (char*)"null";
	parse_col[17] = (char*)"else";
	parse_col[18] = (char*)"||";
	parse_col[19] = (char*)"&&";
	parse_col[20] = (char*)"==";
	parse_col[21] = (char*)"!=";
	parse_col[22] = (char*)"<";
	parse_col[23] = (char*)"<=";
	parse_col[24] = (char*)">";
	parse_col[25] = (char*)">=";
	parse_col[26] = (char*)"+";
	parse_col[27] = (char*)"-";
	parse_col[28] = (char*)"=";
	parse_col[29] = (char*)"*";
	parse_col[30] = (char*)"/";
	parse_col[31] = (char*)"%";
	parse_col[32] = (char*)"$";
	parse_col[33] = (char*)")";
	parse_col[34] = (char*)"}";

	//Now Initializing Parse Table Enteries.
	for (int i = 0; i < non_Terminals; i++)
	{
		for (int j = 0; j < Terminals; j++)
		{
			parse_table[i][j] = NULL;
		}
	}
	//Prog
	parse_table[0][0] = (char*)"Decl Prog'";
	parse_table[0][1] = (char*)"Decl Prog'";
	parse_table[0][2] = (char*)"Decl Prog'";
	parse_table[0][3] = (char*)"Decl Prog'";

	//Prog'
	parse_table[1][0] = (char*)"Decl Prog'";
	parse_table[1][1] = (char*)"Decl Prog'";
	parse_table[1][2] = (char*)"Decl Prog'";
	parse_table[1][3] = (char*)"Decl Prog'";
	parse_table[1][32] = (char*)"epsilon";

	//Decl
	parse_table[2][0] = (char*)"Type id Decl'";
	parse_table[2][1] = (char*)"Type id Decl'";
	parse_table[2][2] = (char*)"Type id Decl'";
	parse_table[2][3] = (char*)"Type id Decl'";

	//Decl'
	parse_table[3][4] = (char*)";";
	parse_table[3][5] = (char*)"( Formals ) StmtBlk";

	//VariDecl
	parse_table[4][0] = (char*)"Variable ;";
	parse_table[4][1] = (char*)"Variable ;";
	parse_table[4][2] = (char*)"Variable ;";
	parse_table[4][3] = (char*)"Variable ;";

	//Variable
	parse_table[5][0] = (char*)"Type id";
	parse_table[5][1] = (char*)"Type id";
	parse_table[5][2] = (char*)"Type id";
	parse_table[5][3] = (char*)"Type id";

	//Type
	parse_table[6][0] = (char*)"int";
	parse_table[6][1] = (char*)"double";
	parse_table[6][2] = (char*)"bool";
	parse_table[6][3] = (char*)"string";

	//Formals
	parse_table[7][0] = (char*)"Variable Formals'";
	parse_table[7][1] = (char*)"Variable Formals'";
	parse_table[7][2] = (char*)"Variable Formals'";
	parse_table[7][3] = (char*)"Variable Formals'";
	parse_table[7][33] = (char*)"epsilon";

	//Formals'
	parse_table[8][6] = (char*)", Variable Formals'";
	parse_table[8][33] = (char*)"epsilon";

	//StmtBlk
	parse_table[9][7] = (char*)"{ StmtBa' }";

	//StmtBa'
	parse_table[10][0] = (char*)"VariDecl StmtBa'";
	parse_table[10][1] = (char*)"VariDecl StmtBa'";
	parse_table[10][2] = (char*)"VariDecl StmtBa'";
	parse_table[10][3] = (char*)"VariDecl StmtBa'";
	parse_table[10][4] = (char*)"StmtBb'";
	parse_table[10][5] = (char*)"StmtBb'";
	parse_table[10][7] = (char*)"StmtBb'";
	parse_table[10][8] = (char*)"StmtBb'";
	parse_table[10][9] = (char*)"StmtBb'";
	parse_table[10][10] = (char*)"StmtBb'";
	parse_table[10][11] = (char*)"StmtBb'";
	parse_table[10][12] = (char*)"StmtBb'";
	parse_table[10][13] = (char*)"StmtBb'";
	parse_table[10][14] = (char*)"StmtBb'";
	parse_table[10][15] = (char*)"StmtBb'";
	parse_table[10][16] = (char*)"StmtBb'";
	parse_table[10][34] = (char*)"epsilon";

	//StmtBb'
	parse_table[11][4] = (char*)"Stmt StmtBb'";
	parse_table[11][5] = (char*)"Stmt StmtBb'";
	parse_table[11][7] = (char*)"Stmt StmtBb'";
	parse_table[11][8] = (char*)"Stmt StmtBb'";
	parse_table[11][9] = (char*)"Stmt StmtBb'";
	parse_table[11][10] = (char*)"Stmt StmtBb'";
	parse_table[11][11] = (char*)"Stmt StmtBb'";
	parse_table[11][12] = (char*)"Stmt StmtBb'";
	parse_table[11][13] = (char*)"Stmt StmtBb'";
	parse_table[11][14] = (char*)"Stmt StmtBb'";
	parse_table[11][15] = (char*)"Stmt StmtBb'";
	parse_table[11][16] = (char*)"Stmt StmtBb'";
	parse_table[11][34] = (char*)"epsilon";

	//Stmt
	parse_table[12][4] = (char*)";";
	parse_table[12][5] = (char*)"Expr";
	parse_table[12][7] = (char*)"StmtBlk";
	parse_table[12][8] = (char*)"IfStmt";
	parse_table[12][9] = (char*)"Wh_St";
	parse_table[12][10] = (char*)"Ret_St";
	parse_table[12][11] = (char*)"Expr";
	parse_table[12][12] = (char*)"Expr";
	parse_table[12][13] = (char*)"Expr";
	parse_table[12][14] = (char*)"Expr";
	parse_table[12][15] = (char*)"Expr";
	parse_table[12][16] = (char*)"Expr";

	//IfStmt
	parse_table[13][8] = (char*)"if ( Expr ) A_0 Stmt IfStmt' A_1";

	//IfStmt'
	parse_table[14][17] = (char*)"A_2 else Stmt";
	parse_table[14][4] = (char*)"epsilon";
	parse_table[14][5] = (char*)"epsilon";
	parse_table[14][7] = (char*)"epsilon";
	parse_table[14][8] = (char*)"epsilon";
	parse_table[14][9] = (char*)"epsilon";
	parse_table[14][10] = (char*)"epsilon";
	parse_table[14][11] = (char*)"epsilon";
	parse_table[14][12] = (char*)"epsilon";
	parse_table[14][13] = (char*)"epsilon";
	parse_table[14][14] = (char*)"epsilon";
	parse_table[14][15] = (char*)"epsilon";
	parse_table[14][16] = (char*)"epsilon";
	parse_table[14][34] = (char*)"epsilon";

	//Wh_St
	parse_table[15][9] = (char*)"while A_3 ( Expr ) A_4 Stmt A_5";

	//Ret_St
	parse_table[16][10] = (char*)"return A_6 Ret_St' ;";

	//Ret_St'
	parse_table[17][5] = (char*)"Expr";
	parse_table[17][11] = (char*)"Expr";
	parse_table[17][12] = (char*)"Expr";
	parse_table[17][13] = (char*)"Expr";
	parse_table[17][14] = (char*)"Expr";
	parse_table[17][15] = (char*)"Expr";
	parse_table[17][16] = (char*)"Expr";

	//Actuals
	parse_table[18][5] = (char*)"Expr Actuals'";
	parse_table[18][11] = (char*)"Expr Actuals'";
	parse_table[18][12] = (char*)"Expr Actuals'";
	parse_table[18][13] = (char*)"Expr Actuals'";
	parse_table[18][14] = (char*)"Expr Actuals'";
	parse_table[18][15] = (char*)"Expr Actuals'";
	parse_table[18][16] = (char*)"Expr Actuals'";
	parse_table[18][33] = (char*)"epsilon";

	//Actuals'
	parse_table[19][6] = (char*)", Expr Actuals'";
	parse_table[19][33] = (char*)"epsilon";

	//Const
	parse_table[20][12] = (char*)"intConst A_10";
	parse_table[20][13] = (char*)"doubConst A_10";
	parse_table[20][14] = (char*)"boolConst A_10";
	parse_table[20][15] = (char*)"strConst A_10";
	parse_table[20][16] = (char*)"null";

	//Expr
	parse_table[21][5] = (char*)"B A'";
	parse_table[21][11] = (char*)"B A'";
	parse_table[21][12] = (char*)"B A'";
	parse_table[21][13] = (char*)"B A'";
	parse_table[21][14] = (char*)"B A'";
	parse_table[21][15] = (char*)"B A'";
	parse_table[21][16] = (char*)"B A'";

	//A'
	parse_table[22][18] = (char*)"|| B A_11 A'";
	parse_table[22][4] = (char*)"epsilon";
	parse_table[22][6] = (char*)"epsilon";
	parse_table[22][19] = (char*)"epsilon";
	parse_table[22][20] = (char*)"epsilon";
	parse_table[22][21] = (char*)"epsilon";
	parse_table[22][22] = (char*)"epsilon";
	parse_table[22][23] = (char*)"epsilon";
	parse_table[22][24] = (char*)"epsilon";
	parse_table[22][25] = (char*)"epsilon";
	parse_table[22][26] = (char*)"epsilon";
	parse_table[22][27] = (char*)"epsilon";
	parse_table[22][29] = (char*)"epsilon";
	parse_table[22][30] = (char*)"epsilon";
	parse_table[22][31] = (char*)"epsilon";
	parse_table[22][33] = (char*)"epsilon";

	//B
	parse_table[23][5] = (char*)"C B'";
	parse_table[23][11] = (char*)"C B'";
	parse_table[23][12] = (char*)"C B'";
	parse_table[23][13] = (char*)"C B'";
	parse_table[23][14] = (char*)"C B'";
	parse_table[23][15] = (char*)"C B'";
	parse_table[23][16] = (char*)"C B'";

	//B'
	parse_table[24][19] = (char*)"&& C A_12 B'";
	parse_table[24][4] = (char*)"epsilon";
	parse_table[24][6] = (char*)"epsilon";
	parse_table[24][18] = (char*)"epsilon";
	parse_table[24][20] = (char*)"epsilon";
	parse_table[24][21] = (char*)"epsilon";
	parse_table[24][22] = (char*)"epsilon";
	parse_table[24][23] = (char*)"epsilon";
	parse_table[24][24] = (char*)"epsilon";
	parse_table[24][25] = (char*)"epsilon";
	parse_table[24][26] = (char*)"epsilon";
	parse_table[24][27] = (char*)"epsilon";
	parse_table[24][29] = (char*)"epsilon";
	parse_table[24][30] = (char*)"epsilon";
	parse_table[24][31] = (char*)"epsilon";
	parse_table[24][33] = (char*)"epsilon";

	//C
	parse_table[25][5] = (char*)"D C'";
	parse_table[25][11] = (char*)"D C'";
	parse_table[25][12] = (char*)"D C'";
	parse_table[25][13] = (char*)"D C'";
	parse_table[25][14] = (char*)"D C'";
	parse_table[25][15] = (char*)"D C'";
	parse_table[25][16] = (char*)"D C'";

	//C'
	parse_table[26][18] = (char*)"epsilon";
	parse_table[26][4] = (char*)"epsilon";
	parse_table[26][6] = (char*)"epsilon";
	parse_table[26][19] = (char*)"epsilon";
	parse_table[26][20] = (char*)"== D A_13 C'";
	parse_table[26][21] = (char*)"!= D A_14 C'";
	parse_table[26][22] = (char*)"epsilon";
	parse_table[26][23] = (char*)"epsilon";
	parse_table[26][24] = (char*)"epsilon";
	parse_table[26][25] = (char*)"epsilon";
	parse_table[26][26] = (char*)"epsilon";
	parse_table[26][27] = (char*)"epsilon";
	parse_table[26][29] = (char*)"epsilon";
	parse_table[26][30] = (char*)"epsilon";
	parse_table[26][31] = (char*)"epsilon";
	parse_table[26][33] = (char*)"epsilon";

	//D
	parse_table[27][5] = (char*)"E D'";
	parse_table[27][11] = (char*)"E D'";
	parse_table[27][12] = (char*)"E D'";
	parse_table[27][13] = (char*)"E D'";
	parse_table[27][14] = (char*)"E D'";
	parse_table[27][15] = (char*)"E D'";
	parse_table[27][16] = (char*)"E D'";

	//D'
	parse_table[28][4] = (char*)"epsilon";
	parse_table[28][6] = (char*)"epsilon";
	parse_table[28][18] = (char*)"epsilon";
	parse_table[28][19] = (char*)"epsilon";
	parse_table[28][20] = (char*)"epsilon";
	parse_table[28][21] = (char*)"epsilon";
	parse_table[28][22] = (char*)"< E A_15 D'";
	parse_table[28][23] = (char*)"<= E A_16 D'";
	parse_table[28][24] = (char*)"> E A_17 D'";
	parse_table[28][25] = (char*)">= E A_18 D'";
	parse_table[28][26] = (char*)"epsilon";
	parse_table[28][27] = (char*)"epsilon";
	parse_table[28][29] = (char*)"epsilon";
	parse_table[28][30] = (char*)"epsilon";
	parse_table[28][31] = (char*)"epsilon";
	parse_table[28][33] = (char*)"epsilon";

	//E
	parse_table[29][5] = (char*)"F E'";
	parse_table[29][11] = (char*)"F E'";
	parse_table[29][12] = (char*)"F E'";
	parse_table[29][13] = (char*)"F E'";
	parse_table[29][14] = (char*)"F E'";
	parse_table[29][15] = (char*)"F E'";
	parse_table[29][16] = (char*)"F E'";


	//E'
	parse_table[30][4] = (char*)"epsilon";
	parse_table[30][6] = (char*)"epsilon";
	parse_table[30][18] = (char*)"epsilon";
	parse_table[30][19] = (char*)"epsilon";
	parse_table[30][20] = (char*)"epsilon";
	parse_table[30][21] = (char*)"epsilon";
	parse_table[30][22] = (char*)"epsilon";
	parse_table[30][23] = (char*)"epsilon";
	parse_table[30][24] = (char*)"epsilon";
	parse_table[30][25] = (char*)"epsilon";
	parse_table[30][26] = (char*)"+ F A_19 E'";
	parse_table[30][27] = (char*)"- F A_20 E'";
	parse_table[30][29] = (char*)"epsilon";
	parse_table[30][30] = (char*)"epsilon";
	parse_table[30][31] = (char*)"epsilon";
	parse_table[30][33] = (char*)"epsilon";

	//F
	parse_table[31][5] = (char*)"G F'";
	parse_table[31][11] = (char*)"G F'";
	parse_table[31][12] = (char*)"G F'";
	parse_table[31][13] = (char*)"G F'";
	parse_table[31][14] = (char*)"G F'";
	parse_table[31][15] = (char*)"G F'";
	parse_table[31][16] = (char*)"G F'";

	//F'
	parse_table[32][4] = (char*)"epsilon";
	parse_table[32][6] = (char*)"epsilon";
	parse_table[32][18] = (char*)"epsilon";
	parse_table[32][19] = (char*)"epsilon";
	parse_table[32][20] = (char*)"epsilon";
	parse_table[32][21] = (char*)"epsilon";
	parse_table[32][22] = (char*)"epsilon";
	parse_table[32][23] = (char*)"epsilon";
	parse_table[32][24] = (char*)"epsilon";
	parse_table[32][25] = (char*)"epsilon";
	parse_table[32][26] = (char*)"epsilon";
	parse_table[32][27] = (char*)"epsilon";
	parse_table[32][29] = (char*)"* G A_21 F'";
	parse_table[32][30] = (char*)"/ G A_22 F'";
	parse_table[32][31] = (char*)"% G A_23 F'";
	parse_table[32][33] = (char*)"epsilon";

	//G
	parse_table[33][5] = (char*)"( Expr )";
	parse_table[33][11] = (char*)"id A_10 G'";
	parse_table[33][12] = (char*)"Const";
	parse_table[33][13] = (char*)"Const";
	parse_table[33][14] = (char*)"Const";
	parse_table[33][15] = (char*)"Const";
	parse_table[33][16] = (char*)"Const";

	//G'
	parse_table[34][4] = (char*)"epsilon";
	parse_table[34][5] = (char*)"A_8 ( Actuals )";
	parse_table[34][6] = (char*)"epsilon";
	parse_table[34][18] = (char*)"epsilon";
	parse_table[34][19] = (char*)"epsilon";
	parse_table[34][20] = (char*)"epsilon";
	parse_table[34][21] = (char*)"epsilon";
	parse_table[34][22] = (char*)"epsilon";
	parse_table[34][23] = (char*)"epsilon";
	parse_table[34][24] = (char*)"epsilon";
	parse_table[34][25] = (char*)"epsilon";
	parse_table[34][26] = (char*)"epsilon";
	parse_table[34][27] = (char*)"epsilon";
	parse_table[34][28] = (char*)"= Expr A_9";
	parse_table[34][29] = (char*)"epsilon";
	parse_table[34][30] = (char*)"epsilon";
	parse_table[34][31] = (char*)"epsilon";
	parse_table[34][33] = (char*)"epsilon";

	/*
	parse_table[0][0] = (char*)"T E'";
	parse_table[0][3] = (char*)"T E'";


	parse_table[1][1] = (char*)"+ T E'";
	parse_table[1][4] = (char*)"epsilon";
	parse_table[1][5] = (char*)"epsilon";


	parse_table[2][0] = (char*)"F T'";
	parse_table[2][3] = (char*)"F T'";


	parse_table[3][1] = (char*)"epsilon";
	parse_table[3][2] = (char*)"* F T'";
	parse_table[3][4] = (char*)"epsilon";
	parse_table[3][5] = (char*)"epsilon";

	parse_table[4][0] = (char*)"id";
	parse_table[4][3] = (char*)"( E )";
*/
}

//
//bool isEqual(char* a, char* b)
//{
//	//It returns true if both arrays are equal.
//	//cout << "isEqual, a:" << a << "b:" << b << endl;
//	int i = 0;
//	while (a[i] == b[i] && a[i] != '\0' && b[i] != '\0')
//	{
//		i++;
//	}
//	//i--;
//	if (a[i] == b[i])
//	{
//		///cout << "From isEqual: " << a[i] << "..." << b[i] << "a: " << a << " b: " << b << endl;
//		return true;
//	}
//	else return false;
//}

bool isTerminal(char* a)
{
	for (int i = 0; i < Terminals; i++)
	{
		if (isEqual(a, parse_col[i]))
		{
			return true;
		}
	}
	return false;
}

int Terminal_index(char* a)
{
	for (int i = 0; i < Terminals; i++)
	{
		if (isEqual(a, parse_col[i]))
		{
			return i;
		}
	}
	return -1;
}

int non_Terminal_index(char* a)
{
	//It returns index of non_Terminal to be matched...
	for (int i = 0; i < non_Terminals; i++)
	{
		if (isEqual(a, parse_row[i]))
		{
			//cout << "non_Terminals matched..." << "Input:" << a << ". matched:" << parse_col[i] << endl;
			return i;
		}
	}
	//cout << "Input in this function is not in non_Terminal list..." << endl;
	return -1;
}

bool str_copy(char* des, char* src, int start_index, int bytes)
{
	//It will copy "bytes" Bytes src from start_index into des.
	//It will not copy beyond the end of src string.

	/*
	cout << "I am in str_copy." << endl;
	cout << "Source is: " << src << endl;
	cout << "Start index is: " << start_index << endl;
	cout << "Length to be copied is: " << bytes << endl;
	*/
	int i = start_index;
	int count = 0;
	for (; src[i] != '\0' && count < bytes; i++)
	{
		//cout << "i is: " << i << endl;
		//des[i - start_index] = src[i];			//updating this line. different from a lex.
		des[count] = src[i];
		count++;
	}
	//cout << "Loop is done from str_copy." << endl;
	des[i - start_index] = '\0';
	return true;

}

int isConst(char* a)
{
	//It storeas constant types.
	char** constTypes;

	//It stores Total constant exists.
	int T_const = 4;

	//It is true if input part is matched with Constant Type. 
	bool match = false;

	constTypes = new char*[T_const];

	constTypes[0] = (char*)"intConst,";
	constTypes[1] = (char*)"doubConst,";
	constTypes[2] = (char*)"strConst,";
	constTypes[3] = (char*)"boolConst,";		//true, false, and null are in bool constant.

	int j;
	
	for (int i = 0; i < T_const; i++)
	{
		j = 0;
		//for (int j = 0; j < strlen(constTypes[i]); i+st+)
		while(a[j]==constTypes[i][j])
		{
			j++;
		}
		if (j == strlen(constTypes[i]))
		{
			return i+1;
		}
	}
	return 0;
}

//Action notation is: A_*				('.' * means action number).
bool syntax_analyzer(char* a)
{
	//cout << "Syntax Analyzer is called..." << endl;
	fstream ofstream;
	ofstream.open("syntax_input.txt", ios::app);
	ofstream << a << endl;
	ofstream.close();
	char id_name[20];				//It stores name of identifier used in source program.
	
	//It stores type of input,
	//intConst, doubConst, strConst, boolConst
	//and zero for all Others  except NULL. 
	int constType = 0; 
	constType = isConst(a);

	//It stores data of constant type.
	char* constData;
	constData = new char[strlen(a)];

	if ('i' == a[0] && 0 == constType)
	{
		if ('\0' != a[1] && 'd' == a[1])
		{
			//cout << "Identifier is an input of a syntax: " << a << endl;
			//cout << a << endl;
			str_copy(id_name, a, 3, strlen(a) - 3);
			//str_copy()
			a[2] = '\0';
		}
	}

	//Check if input is ConstType.
	else
	{
		switch (constType)
		{
		case 0:
			//cout << "Case 0 of constType, a: " << a << endl;
			break;
		case 1:
			//intConst
			//Copy Constant data in another array.
			str_copy(constData, a, 9, strlen(a) - 9);
			a[8] = '\0';
			cout << "ConstInput, a: " << a << ", Data: " << constData << "." << endl;
			//system("pause");
			break;
		case 2:
			//doubConst
			//Copy Constant data in another array.
			str_copy(constData, a, 10, strlen(a) - 10);
			a[9] = '\0';
			cout << "ConstInput, a: " << a << ", Data: " << constData << "." << endl;
			//system("pause");
			break;
		case 3:
			//Copy Constant data in another array.
			str_copy(constData, a, 9, strlen(a) - 9);
			a[8] = '\0';
			cout << "ConstInput, a: " << a << ", Data: " << constData << "." << endl;
			//system("pause");
			break;
		case 4:
			//Copy Constant data in another array.
			str_copy(constData, a, 10, strlen(a) - 10);
			a[9] = '\0';
			cout << "ConstInput, a: " << a << ", Data: " << constData << "." << endl;
			//system("pause");
			break;
		default:
			cout << "Default case of consType. Input is: " << a << endl;
			cout << "constType value is: " << constType << endl;
		}
		/*
		cout << "Syntax Input is: " << a << endl;
		if (constType)
		{
			cout << "Constant data is: " << constData << endl;
		}
		system("pause");
		return 0;*/
	}


	//***************************Ignore kroo...Remove above Return******************.

	/*
	HANDLE file;
	file = CreateFileA("syntax_input.txt", GENERIC_WRITE | GENERIC_READ, FILE_READ_ACCESS | FILE_WRITE_ACCESS, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);


	WriteFile(file, a, strlen(a), NULL, 0);
	WriteFile(file, (LPVOID)'\n', 1, NULL, 0);
	CloseHandle(file);
	*/


	char* pop_prod = NULL;				//Stores pop element from a stack to be replaced.
	int non_terminal_index;				//It stores index of non-Terminal which is replaced with a production.
	int terminal_index;					//It stores index of input Terminal in a parse table.
	char* push_prod = NULL;				//It stores production to be pushed in a stack.
	int stop_push = 0;					//It stores index to be pushed in a stack.
	int prod_len;						//It stores length of a production to be pushed in the stack.
	char* push_token;					//It stores topken to be pushed in the stack.
	int action_num = -1;				//It stores action number to be performed.

	//while (!prod.empty())
	while(true)
	{
		//cout << "In a loop..." << endl;
		pop_prod = prod.top();
		prod.pop();

		cout << "Poped from top of a stack is: " << pop_prod << endl;
		if ('A' == pop_prod[0] && '_' == pop_prod[1])
		{
			//Action is poped from a stack.
			//Call specific function to perform an action.
			action_num = atoi(pop_prod + 2);
			cout << "Action is poped. It's num is: " << action_num << endl;
			cout << "Poped is: " << pop_prod << "." << endl;
			//char* fzool = pop_prod;


			switch (action_num)
			{
			case 0:
				Action_0();
				break;
			case 1:
				Action_1();
				break;
			case 2:
				Action_2();
				break;
			case 3:
				Action_3();
				break;
			case 4:
				Action_4();
				break;
			case 5:
				Action_5();
				break;
			case 6:
				Action_6();
				break;
			case 7:
				Action_7();
				break;
			case 8:
				Action_8();
				break;
			case 9:
				Action_9();
				break;
			//case 11:
			default:
				if (10 != action_num)
				{
					action_num -= 11;
					Action_11(action_num);
				}
			}

			//
			//if (action_num < 10)
			//{
			//	//init_Action();
			//	ActionMap[pop_prod]();
			//	//ActionMap[fzool]();
			//}
			//else if (action_num > 10)
			//{
			//	action_num -= 11;
			//	Action_11(action_num);
			//}
			
			//system("pause");

			//Continue after performing action.
			continue;
		}
		//push_count--;

		//Below Statements are used in scope checking. 
		if (isEqual((char*)"Decl", pop_prod))
		{
			func_decl = true;
			semantic_temp = new semantic;
		}
		else if (isEqual((char*)"Variable", pop_prod) || isEqual((char*)"VariDecl", pop_prod))
		{
			variable_decl = true;
			semantic_temp = new semantic;
			//cout << "Variabe is going to be declared." << endl;
			//system("pause");
		}
		else if (isEqual((char*)"StmtBlk", pop_prod))
		{
			if (func_decl)
			{
				func_decl = false;
			}
			else initialize_scope();
		}

		//This statement is used in type checking.
		if (isEqual((char*)"StmtBlk", pop_prod) || isEqual((char*)";", pop_prod))
		{
			operator_check = false;
			prev_id_name[0] = '\0';

			//cout << "Operator check is reset." << endl;
			//system("pause");
		}

		//cout << "Updated top of a stack is: " << prod.top() << endl;
		//If stack top of production is reached at terminal symbol.
		if (isTerminal(pop_prod))
		{
			//cout << "Terminal is identified..." << endl;
			//if (isEqual(pop_prod, input[i]))
			//If production is Terminal It should match with Input.
			if (isEqual(pop_prod, a))
			{
				//cout << "Input part is matched." << endl;
				//cout << "Stack top: " << pop_prod << endl;
				//cout << "Input: " << input[i] << endl;
				//cout << "Input: " << a << endl;
				//cout << "\n\n\n\n\n";

				//Now  store symbol table information if it is declaration.
				//These operation s are for scope Checking.
				if (variable_decl)
				{
					if (isEqual((char*)"id", a))
					{
						semantic_temp->set_id(id_name);		//Store name of declaration.
						variable_decl = false;

						//Insert node at start of vecor.
						//Make sure, this variable is declared first time in this scope.
						//if (isVariDecl(symbol_table, semantic_temp))
						//It will be true if variable is used before declaration.
						if (isVariDecl(id_name, false))
						{
							cout << "This variable is already declared in this scope." << endl;
							cout << "Variable name is: " << semantic_temp->get_id() << endl;
							//system("pause");
						}
						else
						{
							//cout << "New Declaration of " << semantic_temp->get_id() << endl;
							symbol_table.insert(symbol_table.begin(), semantic_temp);
						}

						operator_check = false;
						prev_id_name[0] = '\0';
					}
					else
					{
						semantic_temp->set_type(a);			//Store type of declaration.
						//cout << "Type is set: " << semantic_temp->get_type() << endl;
						//system("pause");
					}
				}

				else if (func_decl)
				{
					if (isType(a))
					{
						semantic_temp->set_type(a);
					}
					else if (isEqual((char*)"id", a))
					{
						semantic_temp->set_id(id_name);
					}
					else if (isEqual((char*)";", a))
					{
						//cout << "Variable is declared using Decl.";
						semantic_temp->set_func(false);
						//It will  be true if Variable is used before declaration.
						if (isVariDecl(id_name, false))		//Check this variable is declared in this scope.
						{
							cout << "This variable is already declared in this scope." << endl;
							cout << "Variable name is: " << semantic_temp->get_id() << endl;
							//system("pause");
						}
						else
						{
							//cout << "New Declaration of " << semantic_temp->get_id ()<< endl;
							symbol_table.insert(symbol_table.begin(), semantic_temp);
						}
						operator_check = false;
						prev_id_name[0] = '\0';
					}
					else if (isEqual((char*)"(", a))
					{
						//cout << "Function is declared." << endl;
						semantic_temp->set_func(true);				//It stores function declaration.
						symbol_table.insert(symbol_table.begin(), semantic_temp);
						initialize_scope();							//It inserts delimeter of new scope.						

						operator_check = false;
						prev_id_name[0] = '\0';
					}
				}

				else if (isEqual((char*)"}", a))		//Checks end of the scope.
				{
					//This function pops the recent scope uploaded.
					//cout << "Poping recent scope." << endl;
					pop_recent_scope();

				}

				else if (isEqual((char*)"id", a))
				{
					//Check if identifier is used.
					//It will be true if variable is used before declaration.
					if (!isVariDecl(id_name, true))
					{
						cout << "This variable is used before declaration." << endl;
						cout << "Variable Name  is: " << id_name << endl;
						//system("pause");
					}

					//else
					//{
					//	//operator_check = false;				//it helps in type checking.
					//	if (!check_type(prev_id_name, id_name))
					//	{
					//		cout << "type of these expressions is not matched." << endl;
					//		cout << "Variable name is: " << prev_id_name << endl;
					//		system("pause");
					//	}
					//	//prev_id_name[0] = '\0';
					//} 

					//
					//if (!operator_check)
					//{
					//	str_copy(prev_id_name, id_name, strlen(id_name));
					//	operator_check = true;
					//}
					//else
					//{
					//	operator_check = false;				//It helps in type checking.
					//	if (!check_type(prev_id_name, id_name))
					//	{
					//		cout << "Type of these expressions is not matched." << endl;
					//	}
					//	prev_id_name[0] = '\0';
					//} 

				}



				//These operations are for type checking.
				if (isEqual((char*)"id", a) && !operator_check)
				{
					operator_check = true;
					str_copy(prev_id_name, id_name, strlen(id_name));
				}
				else if (isEqual((char*)"id", a) && operator_check && strlen(prev_id_name) > 0)
				{
					//It is true if type mis match.
					if (!check_type(id_name, prev_id_name))
					{
						cout << "Type Mis Match: " << prev_id_name << endl;
						cout << "Type Mis Match: " << id_name << endl;

						//print_symbol_table();

						//system("pause");
					}
				}
				else if (isConstant(a) && operator_check && strlen(prev_id_name) > 0)
				{
					//It will be true if type mis match occurs.
					if (!comp_type(prev_id_name, get_const_type(a)))
					{
						cout << "Type mis Match: " << prev_id_name << endl;
						//cout << "Type of var is: " << get_type_name(a) << endl;
						cout << "Type mis Match: " << a << endl;
						//cout << "Type of Constant is: " << get_const_type(a) << endl;


						//print_symbol_table();

						//system("pause");
					}
				}

				if (isConstant(a))
				{
					Action_10(constData);
				}
				else if (a[0] == 'i' && a[1] == 'd' && isEqual(prod.top(), (char*)"A_10"))
				{
					//cout << prod.pop();
					prod.pop();
					Action_10(id_name);
				}
				cout << "Input is matched. It is: " << a << endl;
				//system("pause");

				return true;
			}
			else
			{
				//cout << "Push count is: " << push_count << endl;
				cout << "Sytax of input is not correct...\n";
				cout << "Stack top is: " << pop_prod << endl;
				cout << "Input is: " << a << endl;
				cout << "Exiting a program...\n";
				cout << "Now poping stack elements..." << endl;

				while (!prod.empty())
				{
					cout << prod.top() << endl;
					prod.pop();
					//push_count--;
				}
				cout << "Stack  is  empty..." << endl;
				//cout << "Push_count is: " << push_count << endl;
				stop_program = true;				//Stop execution of program.

				system("pause");
				return false;
			}

		}
		else if (isEqual(pop_prod, (char*)"epsilon"))
		{
			//cout << "Skip this epsilon..." << endl;
			continue;
		}
		else
		{
			//cout << "Input detected is Non-Terminal." << endl;
			//cout << "Element poped from stack is non-Terminal." << endl;
			non_terminal_index = non_Terminal_index(pop_prod);
			//Find corresponding column/Terminal to replace this production.
			//terminal_index = Terminal_index(input[i]);
			terminal_index = Terminal_index(a);

			//Now push production on a stack.
			push_prod = parse_table[non_terminal_index][terminal_index];
			if (NULL == push_prod)
			{
				cout << "Moving in wrong direction..." << endl;
				return false;
			}
			//cout << "Row num is: " << non_terminal_index << endl;
			//cout << "Col num is: " << terminal_index << endl;
			//cout << "Input terminal is: " << input[i] << endl;
			//cout << "Production poped from top of the stack is: " << pop_prod << endl;
			//cout << "Pushing production on a stack is: " << push_prod << endl;

			//cout << strlen(push_prod) << endl;
			prod_len = strlen(push_prod);
			stop_push = prod_len;
			//cout << "Tokenizing production to push on a Stack." << endl;
			//cout << "Length of a production is: " << prod_len << endl;
			for (int j = prod_len - 1; j >= 0; j--)
			{
				//cout << "j is: " << j << endl;
				//cout << "Char is: " << push_prod[j] << endl;
				if (' ' == push_prod[j])
				{
					//cout << "Comma is  identified." << endl;
					//cout << "j is: " << j << endl;
					//cout << "Char is: " << push_prod[j] << endl;
					push_token = new char[stop_push - j + 1];
					str_copy(push_token, push_prod, j + 1, stop_push - (j + 1));
					//cout << "Copy is done." << endl;
					//cout << "Tok"
					stop_push = j;
					//cout << "Updated stop_push is: " << stop_push << endl;
					prod.push(push_token);
					//push_count++;
					//cout << "Token pushed on a stack is: " << push_token << endl;
					//cout << "Top of the stack is: " << prod.top() << endl;
				}
				else if (0 == j)
				{
					push_token = new char[stop_push - j];
					str_copy(push_token, push_prod, j, stop_push - j);
					//cout << "Copy is done." << endl;
					//cout << "Tok"
					prod.push(push_token);
					//push_count++;
					//cout << "Token pushed on a stack is: " << push_token << endl;
					//cout << "Top of the stack is: " << prod.top() << endl;
					//push_token[stop_push] = ' ';
					stop_push = j;
				}
			}
		}
	}

	return false;
}

//Now Lexical Analyzer Functions, below...

bool str_copy(char* des, char* src, int size)
{

	//It copies size bytes from src to des.
	int i = 0;
	for (; src[i] != '\0' && i < size; i++)
	{
		des[i] = src[i];
	}
	des[i] = '\0';
	return true;
}

//
//bool str_copy(char* des, char* src, int start_index, int bytes)
//{
//	//It will copy "bytes" Bytes src from start_index into des.
//	//It will not copy beyond the end of src string.
//	int i = start_index;
//	int count = 0;
//	for (; src[i] != '\0' && count < bytes; i++)
//	{
//		des[i - start_index] = src[i];
//		count++;
//	}
//	des[i - start_index] = '\0';
//	return true;
//
//}

//Initialization functions...
bool init_KeyWords()
{
	//It will initialize keyWords.
	keyWords = new char* [max_Token_length];
	keyWords[0] = (char*)"void";
	keyWords[1] = (char*)"int";
	keyWords[2] = (char*)"double";
	keyWords[3] = (char*)"bool";
	keyWords[4] = (char*)"string";
	keyWords[5] = (char*)"class";
	keyWords[6] = (char*)"interface";
	keyWords[7] = (char*)"null";
	keyWords[8] = (char*)"this";
	keyWords[9] = (char*)"extends";
	keyWords[10] = (char*)"implements";
	keyWords[11] = (char*)"for";
	keyWords[12] = (char*)"while";
	keyWords[13] = (char*)"if";
	keyWords[14] = (char*)"else";
	keyWords[15] = (char*)"return";
	keyWords[16] = (char*)"break";
	keyWords[17] = (char*)"New";
	keyWords[18] = (char*)"NewArray";
	keyWords[19] = (char*)"Print";
	keyWords[20] = (char*)"ReadInteger";
	keyWords[21] = (char*)"ReadLine";
	return true;
	/*cout << "key: " << keyWords << endl;
	cout << "key[0]: " << keyWords[0] << endl;
	cout << "key[1]: " << keyWords[1] << endl;*/


}

bool init_bool_constants()
{
	bool_constants = new char* [2];
	bool_constants[0] = (char*)"true";
	bool_constants[1] = (char*)"false";
	return true;
}

bool init_operators()
{
	operators = new char* [18];
	operators[0] = (char*) "+";
	operators[1] = (char*) "-";
	operators[2] = (char*) "*";
	operators[3] = (char*) "/";
	operators[4] = (char*) "%";
	//operators[5] = (char*) "<=";
	operators[5] = (char*) "<";
	//operators[7] = (char*) ">=";
	operators[6] = (char*) ">";
	//operators[9] = (char*) "==";
	//operators[10] = (char*) "!=";
	operators[7] = (char*) "=";
	//operators[12] = (char*) "&&";
	//operators[13] = (char*) "||";
	operators[8] = (char*) "!";
	operators[9] = (char*) ";";
	operators[10] = (char*) ",";
	operators[11] = (char*) ".";
	operators[12] = (char*) "[";
	operators[13] = (char*) "]";
	operators[14] = (char*) "(";
	operators[15] = (char*) ")";
	operators[16] = (char*) "{";
	operators[17] = (char*) "}";
	return true;
}


//DFA functions...
bool isNum(char a)
{
	//It returns true if input character is a digit [0 - 9].
	if (a > 47 && a < 58)
	{
		//cout << "Input for isNum is: " << (char)a << " .It is accepted." << endl;
		return true;
	}
	else return false;
}

bool isLetter(char a)
{
	//It returns true if input character is an alphabet.
	//cout << "Input for isLetter: " << a << endl;
	if ((a > 64 && a < 91) || (a > 96 && a < 123))
	{
		//cout << "Input for isLetter: " << a << " .It is accepted." << endl;
		return true;
	}
	else return false;
}

int isDecimal(char* a)
{
	int i = 0;
	while (isNum(a[i]))
	{
		i++;
	}
	return i;
	/*
	for (int i = 0; '\0' != a[i]; i++)
	{
		if (!isNum(a[i]))
			return false;
	}
*/
//return true;
}

int isHex(char* a)
{
	//It returns true if it is a Heximal digit.
	int i = 0;
	if (48 == a[0] && (88 == a[1] || 120 == a[1]) && isNum(a[3]))
	{
		i += 3;
		//char digit[max_Token_length];
		//str_copy(digit, a, 2);
		//cout << "Printing from isHex: " << digit << endl;
		//if (isDecimal(digit))
		while (isNum(a[i]))
		{
			i++;
		}
		//fileLocation += i;
		return i;
	}
	else return i;
	//{
		//cout << a << endl;
		//return false;
	//}
}

bool isKeyword(char* a)
{
	for (int i = 0; i < max_Token_length; i++)
	{
		if (isEqual(a, keyWords[i]))
		{
			return true;
		}
	}
	return false;
}

bool isBool(char* a)
{
	//cout << "I am in is bool..." << a << endl;
	for (int i = 0; i < 2; i++)
	{
		//cout << "From isBool..." << endl;
		if (isEqual(a, bool_constants[i]))
		{
			return true;
		}
	}
	return false;
}

bool isOperator(char* a)
{
	//Assuming total number of operators are 24, excluding "/*", "*/".
	//cout << "I am in operators..." <<  a[0] << "!!!" << endl;
	int count = 0;
	//cout << "Accessing operators: " << *(operators[0]) << endl;
	for (int i = 0; i < 18; i++)
	{
		//if (isEqual(a, operators[i]))
		//cout << "Operator to be matched is: " << *(operators[i]) << endl;
		if (a[0] == operators[i][0])
		{
			//cout << "Operator is matched..." << a[0] << endl;
			//count++;
			//if (('<' == a[i] && '=' == a[i+1]))
			if ('<' == a[0] || '>' == a[0] || '!' == a[0] || '=' == a[0])
			{
				//count++;
				if ('=' == a[1])
				{
					count += 2;
					break;
					//return true;
				}
				else
				{
					count++;
					break;
				}
				//return true;
			}
			//return true;
			count++;
			break;
		}
	}
	if (('&' == a[0] && '&' == a[1]) || ('|' == a[0] && '|' == a[1]))
	{
		count += 2;
	}

	if (count)
	{
		char* temp = new char[count];
		str_copy(temp, a, count);
		//cout << "String is accepted: " << temp << endl;

		//cout << "Operator is accepted: " << temp << endl;
		//WriteFile(tokens, "<hex,", 5, NULL, 0);
		//WriteFile(tokens, temp, re, NULL, 0);
		//WriteFile(tokens, ">\n", 2, NULL, 0);
		WriteFile(tokens, temp, strlen(temp), NULL, 0);
		WriteFile(tokens, (LPVOID)"\n", 1, NULL, 0);
		fileLocation += (count - 1);

		if (syntax_analyzer(temp))
		{
			//cout << "Working...." << endl;
		}
		else
		{
			cout << "Your input is not syntatically correct...Operators" << endl;
			system("pause");
			return false;
		}
		return true;
	}
	else return false;
}
//
//bool isDouble(char* a)
//{
//	int i = 0;
//	if (isNum(a[i]))
//	{
//		i++;
//		while (isNum(a[i]))
//		{
//			i++;
//		}
//
//		if (a[i] == '.' && isNum(a[i + 1]))
//		{
//			i += 2;
//			while (isNum(a[i]))
//			{
//				i++;
//			}
//			if ('\0' == a[i])
//			{
//				return true;
//			}
//			if ('E' == a[i])
//			{
//				i++;
//				if ('+' == a[i] || '-' == a[i])
//				{
//					i++;
//				}
//				if (isNum(a[i]))
//				{
//					i++;
//					while (isNum(a[i]))
//					{
//						i++;
//					}
//					if ('\0' == a[i])
//					{
//						return true;
//					}
//					else return false;
//				}
//				else return false;
//			}
//			if ('\0' == a[i])
//			{
//				return true;
//			}
//			else return false;
//
//			if ('\0' == a[i])
//			{
//				return true;
//			}
//			else return false;
//		}
//		else return false;
//
//	}
//
//	return false;
//}

int isDouble(char* a)
{
	int i = 0;
	//if (isNum(a[i]))
	//{
	if ('.' == a[i])
	{
		i++;
		while (isNum(a[i]))
		{
			i++;
		}
		/*
		if ('\0' == a[i])
		{
			return true;
		}
		*/
		if ('E' == a[i])
		{
			i++;
			if ('+' == a[i] || '-' == a[i])
			{
				i++;
			}
			if (isNum(a[i]))
			{
				i++;
				while (isNum(a[i]))
				{
					i++;
				}
				/*
				if ('\0' == a[i])
				{
					return true;
				}
				else return false;
*/

				return i;
			}
			else return 0; //It is an error or Not accepted by double...
		}
		return i;
		/*
		if ('\0' == a[i])
		{
			return true;
		}
		else return false;

		if ('\0' == a[i])
		{
			return true;
		}
		else return false;
*/
	}
	else return i;

	//}

	//return false;
}

bool identifier_check(char a)
{
	//cout << "I am in identifier_check: " << a << endl;
	if (isNum(a) || isLetter(a) || '_' == a)
	{
		return true;
	}
	else return false;
}

//It will identify identifier pattern and than identify keyword, bool or identifier.
void kb_id(char* a)
{
	int i = 0;
	//cout << "kb_id: " << *(a + i) << endl;
	//return;
	while (identifier_check(*(a + i)))
		//while (isNum(*(a+i)) || isLetter(*(a + i)) || '_' == *(a + i))
		/*while ((*(a + i) > 47 && *(a + i) < 58)\
			|| (*(a + i) > 64 && *(a + i) < 91)\
			|| (*(a + i) > 96 && *(a + i) < 123)\
			|| '_' == *(a + i))
		*/
	{
		i++;
		//cout << "From identifier check: " << *(a + i) << endl;
	}
	//cout << endl << endl;
	//cout << "kb_id i is: " << i << endl;
	char* raw_identifier = new char[i]; //It stores identifier, keyword and bool constant.

	str_copy(raw_identifier, a, i);		//It copies identify
	//cout << "raw_identifier is: " << raw_identifier << endl;
	//return;
	if (isKeyword(raw_identifier))
	{
		//cout << "keyword is accepted: " << raw_identifier << endl;
		WriteFile(tokens, "<keyword,", 9, NULL, 0);
		WriteFile(tokens, raw_identifier, i, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);
		//Copy keyword in an array to input it for a parser function.
		//str_copy(parse_input, raw_identifier, strlen(raw_identifier));

		//Now call a syntax analyzer to match corresponding input...
		if (syntax_analyzer(raw_identifier))
		{
			//cout << "Working...." << endl;
		}
		else
		{
			cout << "Your input is not syntatically correct... Kb_id_keyword" << endl;
			system("pause");
			return;
		}
		//cout << "filePointer: " << filePointer << endl;
	}
	else if (isBool(raw_identifier))
	{
		//cout << "Bool is accepted: " << raw_identifier << endl;
		WriteFile(tokens, "<bool,", 6, NULL, 0);
		WriteFile(tokens, raw_identifier, i, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);

		int lenSyntaxInput = 11 + strlen(raw_identifier);
		char* syntaxInput = new char[lenSyntaxInput];
		strcpy_s(syntaxInput, lenSyntaxInput, "boolConst,\0");
		strcat_s(syntaxInput, lenSyntaxInput, raw_identifier);

		if (syntax_analyzer(syntaxInput))
		{
			//cout << "Working...." << endl;
		}
		else
		{
			cout << "Your input is not syntatically correct... kb_id_bool" << endl;
			//cout << "Input to syntax Analyzer is: " << raw_identifier << endl;
			system("pause");
			return;
		}
	}
	else
	{
		//cout << "Identifier is accepted: " << raw_identifier << endl;
		WriteFile(tokens, "<id,", 4, NULL, 0);
		WriteFile(tokens, raw_identifier, i, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);

		//WriteFile(identifiers, "<Keyword,", 9, NULL, 0);
		WriteFile(identifiers, raw_identifier, i, NULL, 0);
		WriteFile(identifiers, "\n", 1, NULL, 0);

		char semantic_input[25];
		semantic_input[0] = 'i';
		semantic_input[1] = 'd';
		semantic_input[2] = ',';
		str_copy((semantic_input + 3), raw_identifier, strlen(raw_identifier));
		//if (syntax_analyzer((char*)"id"))
		if (syntax_analyzer(semantic_input))
		{
			//cout << "Working...." << endl;
		}
		else
		{
			cout << "Your input is not syntatically correct... kb_id_identifier" << endl;
			system("pause");
			return;
		}
	}

	fileLocation += (i - 1);
	/*
	cout << "kb_id, Freeing memory..." << endl;
	delete[] raw_identifier;
	cout << "kb_id, memory is freed..." << endl;
*/

	return;
}

void numeric(char* a)
{
	//cout << "Numeric is called..." << endl;
	int i = fileLocation;
	int ret_fun = 0;

	ret_fun = isHex(a);
	if (ret_fun)
	{
		char* temp = new char[ret_fun];
		str_copy(temp, a, ret_fun);
		WriteFile(tokens, "<hex,", 5, NULL, 0);
		WriteFile(tokens, temp, ret_fun, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);
		fileLocation += (ret_fun - 1);

		int lenSyntaxInput = 10 + strlen(temp);
		//char* syntaxInput = new char[strlen(temp) + 9];
		char* syntaxInput = new char[lenSyntaxInput];
		strcpy_s(syntaxInput, lenSyntaxInput, "intConst,\0");
		strcat_s(syntaxInput, lenSyntaxInput, temp);

		//if (!syntax_analyzer((char*)"intConst"))
		if (!syntax_analyzer(syntaxInput))
		{
			cout << "Your input is not syntatically correct... numeric_hex" << endl;
			cout << "Input to syntax is: " << syntaxInput << endl;
			system("pause");
			return;
		}
		return;
	}
	ret_fun = isDecimal(a);
	if (ret_fun)
	{
		int deci_val = ret_fun;
		ret_fun = isDouble((a + deci_val));
		if (ret_fun)
		{
			ret_fun += deci_val;
			char* temp = new char[ret_fun];
			str_copy(temp, a, ret_fun);
			WriteFile(tokens, "<double,", 8, NULL, 0);
			WriteFile(tokens, temp, ret_fun, NULL, 0);
			WriteFile(tokens, ">\n", 2, NULL, 0);


			//It stores size of array to be declared dynamically.
			int lenSyntaxInput = 11 + strlen(temp);
			char* syntaxInput = new char[lenSyntaxInput];
			//syntaxInput[0] = '\0';
			strcpy_s(syntaxInput, lenSyntaxInput, (char*)"doubConst,\0");
			strcat_s(syntaxInput, lenSyntaxInput, temp);

			//if (!syntax_analyzer((char*)"doubConst"))
			if (!syntax_analyzer(syntaxInput))
			{
				cout << "Your input is not syntatically correct...numeric_double" << endl;
				system("pause");
				return;
			}
		}
		else
		{
			ret_fun = deci_val;
			char* temp = new char[ret_fun];
			str_copy(temp, a, ret_fun);
			WriteFile(tokens, "<decimal,", 9, NULL, 0);
			WriteFile(tokens, temp, ret_fun, NULL, 0);
			WriteFile(tokens, ">\n", 2, NULL, 0);

			//It stores size of array to be declared dynamically.
			int lenSyntaxInput = 10 + strlen(temp);
			//char* syntaxInput = new char[strlen(temp) + 9];
			char* syntaxInput = new char[lenSyntaxInput];
			//cout << "Length of temp is: " << strlen(temp) <<'\t'<<(int)temp[3]<< endl;
			//cout << "Length of syntaxInput is: " << strlen(syntaxInput) <<'\t' << (int)syntaxInput[12] << endl;
			//cout << "Data in lenSyntaxInput is: " << lenSyntaxInput << endl;
			//syntaxInput[10] = '\0';
			//cout << "Length of syntaxInput is: " << strlen(syntaxInput) << endl;
			strcpy_s(syntaxInput, lenSyntaxInput, "intConst,\0");
			//str_copy(syntaxInput, (char*)"intConst,", 9);
			//str_copy()
			//syntaxInput[lenSyntaxInput] = '\0';
			//cout << strlen(syntaxInput) << '\t'  << endl;
			strcat_s(syntaxInput, lenSyntaxInput, temp);

			//if (!syntax_analyzer((char*)"intConst"))
			if (!syntax_analyzer(syntaxInput))
			{
				cout << "Your input is not syntatically correct... numeric_decimal" << endl;
				cout << "Input to syntax Analyzer is:" << syntaxInput << "." << endl;
				system("pause");
				return;
			}
		}
		fileLocation += (ret_fun - 1);
	}
	return;
}

bool isString(char* a)
{
	int i = 0;
	if (34 == a[i])
		//if(63 == a[i])
	{
		//cout << "isString, " << (int)a[i] << endl;
		i++;
		//cout << "isString, " << a[i] << endl;
		while (a[i] != 34)
			//while (a[i] != 63)
		{
			i++;
		}
		char* temp = new char[i];
		str_copy(temp, (a + 1), i - 1);
		//cout << "String is accepted: " << temp << endl;
		WriteFile(tokens, "<str,", 5, NULL, 0);
		WriteFile(tokens, temp, i - 1, NULL, 0);
		WriteFile(tokens, ">\n", 2, NULL, 0);

		int lenSyntaxInput = strlen(temp) + 10;
		char* syntaxInput = new char[lenSyntaxInput];
		
		//strcpy_s(syntaxInput, )
		strcpy_s(syntaxInput, lenSyntaxInput, (char*)"strConst,\0");
		strcat_s(syntaxInput, lenSyntaxInput, temp);

		//if (syntax_analyzer((char*)"strConst"))
		if(syntax_analyzer(syntaxInput))
		{
			//cout << "Working...." << endl;
		}
		else
		{
			cout << "Your input is not syntatically correct...isString" << endl;
			system("pause");
			return false;
		}
		fileLocation += i;
		return true;
	}
	else return false;
}

bool isComment(char* a)
{
	//cout << "I am in isComment..." << endl;
	int i = 0;
	if ('/' == a[i])
	{
		i++;
		if ('/' == a[i]) //One linne comment.
		{
			i++;
			while ('\n' != a[i])
			{
				i++;
			}
			char* temp = new char[i];
			str_copy(temp, (a), i - 1);
			//cout << "Single line comment is accepted: " << temp << endl;
			fileLocation += i;
			return true;
		}
		else if ('*' == a[i])//Multi line comments...
		{
			i++;
			while (true)
			{
				if ('*' == a[i] && '/' == a[i + 1])
				{
					i++;
					break;
				}
				i++;
			}
			char* temp = new char[i];
			str_copy(temp, (a), i);
			//cout << "Multi line comment is accepted: " << temp << endl;

			fileLocation += i;
			return true;
		}
		else return false;
	}
	else return false;
}

char* parser()
{
	char a[32];	//It stores string to be returned, max length of identifer is 31.
	int start = fileLocation;
	//bool
	int op_ret;
	op_ret = isOperator((filePointer + fileLocation)); //This line is incomplete, it will be updated.

	while ((filePointer[fileLocation] != '\n') && (filePointer[fileLocation] != '\t') \
		&& (filePointer[fileLocation] != '"') && !isOperator(filePointer + fileLocation) \
		&& (filePointer[fileLocation] != ' '))
	{
		//if
		fileLocation++;
	}
	str_copy(a, (filePointer + start), 0, (fileLocation - start));


	return a;

}


//Below are the functions used in intermediate  code generation.
void codeGeneration()
{

}

//Defining Actions for Intermediate Code Generation.
void Action(int a)
{
	//Pop "02" operands from top a id_stack and place + in between them.
	
	
	/*char* expOp[13];

	expOp[0] = (char*)"||";*/	
	cout << "t" << registerCount << " = ";
	cout << id_stack.top();
	id_stack.pop();
	switch (a)
	{
	case 0:
		cout << " || ";
	case 1:
		cout << " && ";
	case 2:
		cout << " == ";
	case 3:
		cout << " != ";
	case 4:
		cout << " < ";
	case 5:
		cout << " <= ";
	case 6:
		cout << " > ";
	case 7:
		cout << " >= ";
	case 8:
		cout << " + ";
	case 9:
		cout << " - ";
	case 10:
		cout << " * ";
	case 11:
		cout << " / ";
	case 12:
		cout << " % ";
	}
	cout << id_stack.top();
	cout << endl;
	registerCount++;

}

//
//void Action_0()
//{
//	//It will perform action embed in IfStmt.
//	//Insert new Queue in stack of label_stack.
//
//	cout << "Action_0 is called." << endl;
//	cout << "register_number is: " << register_number << endl;
//	cout << "labelCount is: " << labelCount << endl;
//
//	
//	int regNum = register_number;
//	regNum--;
//	queue<int> *a;
//	char num[5];			//Stores number in char* to store in file.
//	//string code;			//Stores code to be written in a file.
//
//	a = new queue<int>;
//	//char
//	//Insert new Queue for an IF in a stack.
//	labels_stack.push(a);
//
//	//Insert label counts in a queue.
//	a->push(labelCount);
//
//	_itoa_s(register_number, num, 10);
//	WriteFile(code_file, (char*)"if R", 4, NULL, NULL);
//	WriteFile(code_file, num, strlen(num), NULL, NULL);
//
//	_itoa_s(labelCount, num, 10);
//	WriteFile(code_file, (char*)" goto L", 7, NULL, NULL);
//	WriteFile(code_file, num, strlen(num), NULL, NULL);
//
//	//code = "if L" + labelCount;
//	labelCount++;
//	a->push(labelCount);
//	_itoa_s(labelCount, num, 10);
//	WriteFile(code_file, (char*)"\ngoto L", 7, NULL, NULL);
//	WriteFile(code_file, num, strlen(num), NULL, NULL);
//
//	//regNum = a->front();
//	_itoa_s(a->front(), num, 10);
//	a->pop();
//	WriteFile(code_file, (char*)"\nL", 2, NULL, NULL);
//	WriteFile(code_file, num, strlen(num), NULL, NULL);
//	WriteFile(code_file, (char*)":\n", 2, NULL, NULL);
//
//	cout << "Data has been written in a file." << endl;
//
//	
//	//Writing code in a file.
//	//WriteFile(code_file, (char*)"if L", );
//	
//	//cout << "if goto L"<< 
//}
//


int main()
{

	//int a = 0;
	//char* b = (char*)"12345";
	//a = atoi(b + 2);
	//cout << a << endl;
	//return 0;

	//vector<int> a;
	//a.insert(a.begin(), 1);
	//return 0;

/*
	semantic_temp = new semantic;
	semantic_temp->set_func();

	semantic_temp->set_type((char*)"int");
	cout << semantic_temp->get_type() << endl;

	semantic_temp->set_id((char*)"chl rha");
	cout << semantic_temp->get_id() << endl;

	//Inserting element in symbol table.
	symbol_table->insert(semantic_temp, 0);
	return 0;
//*/


	//Test of string and int concatenate.
	/*
	string a;
	string i;
	i = _itoa_s(3, 0, 10);
	_itoa_s(3, i, 10);
	a = "Hello: " + i;
	cout << a << endl;
	return 0;*/
	//char* a = (char*)"abc";

	/*
	id_stack.push((char*)"abc");
	id_stack.push((char*)"def");
	Action_11(6);

	return 0;*/

	//Mapping file into a memory...
	HANDLE open;						//It stores Handle of a code file.
	LPCSTR name = "scope.txt";				//Name of a code file...
	HANDLE mem;							//Stores the handle of Memory mapping.
	DWORD f_size;						//Stores size of a file.
	char* test;							//It stores input file...
	//*
	open = CreateFileA(name, GENERIC_WRITE | GENERIC_READ, FILE_READ_ACCESS, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (open == INVALID_HANDLE_VALUE)
	{
		cout << "Error in reading a file. Code is: " << GetLastError() << endl;
		return -1;
	}
	else
	{
		f_size = GetFileSize(open, 0);
		if (f_size == 0xFFFFFFFF && GetLastError() != 0)
			cout << "Error in getting size of " << name << ". Error is: " << GetLastError() << endl;
		mem = CreateFileMappingA(open, NULL, PAGE_READONLY, 0, f_size, 0);
		if (mem == NULL)
		{
			cout << "Error in creating FileMapping of: " << name << ". Error is: " << GetLastError() << endl;
			//system("pause");
			return -1;
		}

		test = (char*)MapViewOfFile(mem, FILE_MAP_READ, 0, 0, f_size);
		if (test == NULL)
		{
			cout << "Error in creating MapView of: " << name << ". Error is: " << GetLastError() << endl;
			//system("pause");
			return -1;
		}
	}

	//Creating files for Tokens and Identifer.
	tokens = CreateFileA("words.txt", GENERIC_WRITE, FILE_READ_ACCESS, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (INVALID_HANDLE_VALUE == tokens)
	{
		cout << "Error in Creating a words.txt file. Code is: " << GetLastError() << endl;
		return -1;
	}

	identifiers = CreateFileA("tabels.txt", GENERIC_WRITE, FILE_READ_ACCESS, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (INVALID_HANDLE_VALUE == identifiers)
	{
		cout << "Error in Creating a tabels.txt file. Code is: " << GetLastError() << endl;
		return -1;
	}

	//*/
	//It will save Intermediate code generated using this code.
	code_file = CreateFileA("intermediate_code.txt", GENERIC_WRITE, FILE_READ_ACCESS, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (INVALID_HANDLE_VALUE == code_file)
	{
		cout << "Error in Creating a tabels.txt file. Code is: " << GetLastError() << endl;
		return -1;
	}

	//Action_0();
	//return 0;


	init_KeyWords();
	init_bool_constants();
	init_operators();
	init_parse();
	init_Action();
	fileLocation = 0;


	//char* abc = (char*)"A_0";

	//ActionMap[abc]();
	////ActionMap[(char*)"A_0"]();
	//cout << "a_0 is working." << endl;
	//ActionMap[(char*)"A_1"]();
	//cout << "a_1 is working." << endl;
	////actionmap[(char*)"a_2"]();
	////cout << "a_2 is working." << endl;
	//ActionMap[(char*)"A_3"]();
	//cout << "a_3 is working." << endl;
	//ActionMap[(char*)"A_4"]();
	//cout << "A_4 is Working." << endl;
	////ActionMap[(char*)"A_5"]();
	//cout << "A_5 is Working." << endl;
	//ActionMap[(char*)"A_6"]();
	//cout << "A_6 is Working." << endl;
	//ActionMap[(char*)"A_7"]();
	//cout << "A_7 is Working." << endl;
	//ActionMap[(char*)"A_8"]();
	//cout << "A_8 is Working." << endl;
	//ActionMap[(char*)"A_9"]();
	//cout << "A_9 is Working." << endl;
	//return 0;



	//char* test = (char*)"int true a=123;?abcd?123 /efgh.";		//It is used to test a program...
	//char* test = (char*)"//efgh.";		//It is used to test a program...

	//char* test = (char*)"0x123;";		//It is used to test a program...
	//cout << (test) << endl;
	for (; (test[fileLocation] != 0); fileLocation++)
	{
		//cout << "Input is: " << test[fileLocation] << endl;
		if (isLetter(test[fileLocation]))
		{
			//cout << "main kb_id, Input is: " << test[fileLocation] << endl;
			//cout << "test: " << test[i] << endl;
			//cout << "test + i: " << (test + i) << endl;
			kb_id((test + fileLocation));	//It will identify identifier pattern and than identify keyword, bool or identifier.
			//cout << "fileLocation is: " << fileLocation << endl;
		}
		else if (isNum(test[fileLocation]))
			//else if (test[fileLocation] > 47 && test[fileLocation] < 58)
		{
			//cout << "main numeric, Input is: " << test[fileLocation] << endl;
			//cout << "Calling numeric function..." << endl;
			numeric((test + fileLocation));
		}
		else if (isString(test + fileLocation))
		{
			//cout << "main isString, Input in else is: " << test[fileLocation] << endl;
		}
		else if (isComment(test + fileLocation))
		{
			//cout <<"Comment is accepted." << endl; 
		}
		else if (isOperator(test + fileLocation))
		{
			//cout << "operator is accepted..." << endl;
		}
		else
		{
			//cout << "Input in else is: " << test[fileLocation] << endl;
		}
		if (stop_program)
		{
			cout << "Program is going to be terminated." << endl;
			return -1;
			//break;
		}
	}
	if ('\0' == test[fileLocation])
	{
		cout << "Input is finished..." << endl;
		if (!syntax_analyzer((char*)"$"))
		{
			cout << "Syntax of a code is not correct..." << endl;
			system("pause");
			return -1;
		}
	}

	/*
	cout << "Testing inNum..." << test[12] << endl;
	if (isNum(test[12]))
	{
		cout << "isNum is working..." << endl;
	}*/

	/*filePointer = (char*)"int a= 5";
	while ('\0' != filePointer[fileLocation])
	{
		cout << parser() << endl;
	}
	cout << "Done with a parser." << endl;
*/
//char* fileInput = (char*)"int a= 5";
//while()


//char** key_words;
//key_words = {"abc", "def"};

/*char a = '1';
if (isNum(a))
{
	cout << "Num is Working...\n";
}
else cout << "Num is Failed...\n";
*/
/*
	char* digit;
	digit[0] = '1';
	cout << digit << endl;
*/

/*char decimal[] = "12345";
if (isDecimal(decimal))
{
	cout << "isDecimal is Working!!!" << endl;
}
else cout << "isDecimal failed..." << endl;


char hex[] = "0x12345.";
if (isHex(hex))
{
	cout << "isHex is Working!!!" << endl;
}
else cout << "isHex failed..." << endl;
*/

/*
	char** key;
	key = new char*[2];
	key[0] = (char*)"abcd";
	key[1] = (char*)"efghij";

	cout << "key: " << key << endl;
	cout << "key[0]: " << key[0] << endl;
	cout << "key[1]: " << key[1] << endl;
*/
//digit = "1234";

/*char* doub = (char*)"123.4";
if (isDouble(doub))
{
	cout << "isDouble is Done!!!" << endl;
}
else cout << "isDouble is Failed..." << endl;
*/
	UnmapViewOfFile(test);						//Free memory from MapView.
	CloseHandle(mem);							//Closing Handle of CreateFileMapping.
	CloseHandle(tokens);
	CloseHandle(identifiers);

	cout << "Progarm has finished job sucessfully." << endl;
	system("pause");
	return 0;
}
